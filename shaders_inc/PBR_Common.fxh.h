"#ifndef _PBR_COMMON_FXH_\n"
"#define _PBR_COMMON_FXH_\n"
"\n"
"#ifndef FLOAT\n"
"#   define FLOAT float\n"
"#endif\n"
"\n"
"#ifndef FLOAT2\n"
"#   define FLOAT2 float2\n"
"#endif\n"
"\n"
"#ifndef FLOAT3\n"
"#   define FLOAT3 float3\n"
"#endif\n"
"\n"
"#ifndef FLOAT4\n"
"#   define FLOAT4 float4\n"
"#endif\n"
"\n"
"#ifndef EPSILON\n"
"#   define EPSILON 1e-7\n"
"#endif\n"
"\n"
"#define _0f FLOAT(0.0)\n"
"#define _1f FLOAT(1.0)\n"
"#define _2f FLOAT(2.0)\n"
"\n"
"#ifndef PI\n"
"#    define PI FLOAT(3.141592653589793)\n"
"#endif\n"
"\n"
"// Lambertian diffuse\n"
"// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/\n"
"FLOAT3 LambertianDiffuse(FLOAT3 DiffuseColor)\n"
"{\n"
"    return DiffuseColor / PI;\n"
"}\n"
"\n"
"// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n"
"// Implementation of fresnel term from \"An Inexpensive BRDF Model for Physically based Rendering\" by Christophe Schlick\n"
"// https://en.wikipedia.org/wiki/Schlick%27s_approximation\n"
"//\n"
"//      Rf(Theta) = Rf(0) + (1 - Rf(0)) * (1 - cos(Theta))^5\n"
"//\n"
"//\n"
"//           \'.       |       .\'\n"
"//             \'.     |Theta.\'\n"
"//               \'.   |   .\'\n"
"//                 \'. | .\'\n"
"//        ___________\'.\'___________\n"
"//                   \'|\n"
"//                  \' |\n"
"//                 \'  |\n"
"//                \'   |\n"
"//               \' Phi|\n"
"//\n"
"// Note that precise relfectance term is given by the following expression:\n"
"//\n"
"//      Rf(Theta) = 0.5 * (sin^2(Theta - Phi) / sin^2(Theta + Phi) + tan^2(Theta - Phi) / tan^2(Theta + Phi))\n"
"//\n"
"#define SCHLICK_REFLECTION(VdotH, Reflectance0, Reflectance90) ((Reflectance0) + ((Reflectance90) - (Reflectance0)) * pow(clamp(_1f - (VdotH), _0f, _1f), FLOAT(5.0)))\n"
"FLOAT SchlickReflection(FLOAT VdotH, FLOAT Reflectance0, FLOAT Reflectance90)\n"
"{\n"
"    return SCHLICK_REFLECTION(VdotH, Reflectance0, Reflectance90);\n"
"}\n"
"FLOAT3 SchlickReflection(FLOAT VdotH, FLOAT3 Reflectance0, FLOAT3 Reflectance90)\n"
"{\n"
"    return SCHLICK_REFLECTION(VdotH, Reflectance0, Reflectance90);\n"
"}\n"
"\n"
"// Visibility = G2(v,l,a) / (4 * (n,v) * (n,l))\n"
"// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf\n"
"FLOAT SmithGGXVisibilityCorrelated(FLOAT NdotL, FLOAT NdotV, FLOAT AlphaRoughness)\n"
"{\n"
"    // G1 (masking) is % microfacets visible in 1 direction\n"
"    // G2 (shadow-masking) is % microfacets visible in 2 directions\n"
"    // If uncorrelated:\n"
"    //    G2(NdotL, NdotV) = G1(NdotL) * G1(NdotV)\n"
"    //    Less realistic as higher points are more likely visible to both L and V\n"
"    //\n"
"    // https://ubm-twvideo01.s3.amazonaws.com/o1/vault/gdc2017/Presentations/Hammon_Earl_PBR_Diffuse_Lighting.pdf\n"
"\n"
"    FLOAT a2 = AlphaRoughness * AlphaRoughness;\n"
"\n"
"    FLOAT GGXV = NdotL * sqrt(max(NdotV * NdotV * (_1f - a2) + a2, EPSILON));\n"
"    FLOAT GGXL = NdotV * sqrt(max(NdotL * NdotL * (_1f - a2) + a2, EPSILON));\n"
"\n"
"    return FLOAT(0.5) / (GGXV + GGXL);\n"
"}\n"
"\n"
"// Smith GGX shadow-masking function G2(v,l,a)\n"
"FLOAT SmithGGXShadowMasking(FLOAT NdotL, FLOAT NdotV, FLOAT AlphaRoughness)\n"
"{\n"
"    return FLOAT(4.0) * NdotL * NdotV * SmithGGXVisibilityCorrelated(NdotL, NdotV, AlphaRoughness);\n"
"}\n"
"\n"
"// Smith GGX masking function G1\n"
"// [1] \"Sampling the GGX Distribution of Visible Normals\" (2018) by Eric Heitz - eq. (2)\n"
"// https://jcgt.org/published/0007/04/01/\n"
"FLOAT SmithGGXMasking(FLOAT NdotV, FLOAT AlphaRoughness)\n"
"{\n"
"    FLOAT a2 = AlphaRoughness * AlphaRoughness;\n"
"\n"
"    // In [1], eq. (2) is defined for the tangent-space view direction V:\n"
"    //\n"
"    //                                        1\n"
"    //      G1(V) = -----------------------------------------------------------\n"
"    //                                    {      (ax*V.x)^2 + (ay*V.y)^2)  }\n"
"    //               1 + 0.5 * ( -1 + sqrt{ 1 + -------------------------- } )\n"
"    //                                    {              V.z^2             }\n"
"    //\n"
"    // Note that [1] uses notation N for the micronormal, but in our case N is the macronormal,\n"
"    // while micronormal is H (aka the halfway vector).\n"
"    //\n"
"    // After multiplying both nominator and denominator by 2*V.z and given that in our\n"
"    // case ax = ay = a, we get:\n"
"    //\n"
"    //                                2 * V.z                                        2 * V.z\n"
"    //      G1(V) = ------------------------------------------- =  ----------------------------------------\n"
"    //               V.z + sqrt{ V.z^2 + a2 * (V.x^2 + V.y^2) }     V.z + sqrt{ V.z^2 + a2 * (1 - V.z^2) }\n"
"    //\n"
"    // Since V.z = NdotV, we finally get:\n"
"\n"
"    FLOAT Denom = NdotV + sqrt(a2 + (_1f - a2) * NdotV * NdotV);\n"
"    return _2f * max(NdotV, _0f) / max(Denom, EPSILON);\n"
"}\n"
"\n"
"\n"
"// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n"
"// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n"
"// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games, Equation 3.\n"
"FLOAT NormalDistribution_GGX(FLOAT NdotH, FLOAT AlphaRoughness)\n"
"{\n"
"    // \"Sampling the GGX Distribution of Visible Normals\" (2018) by Eric Heitz - eq. (1)\n"
"    // https://jcgt.org/published/0007/04/01/\n"
"\n"
"    // Make sure we reasonably handle AlphaRoughness == 0\n"
"    // (which corresponds to delta function)\n"
"    AlphaRoughness = max(AlphaRoughness, FLOAT(1e-3));\n"
"\n"
"    FLOAT a2  = AlphaRoughness * AlphaRoughness;\n"
"    FLOAT nh2 = NdotH * NdotH;\n"
"    FLOAT f   = nh2 * a2 + (_1f - nh2);\n"
"    return a2 / (PI * f * f);\n"
"}\n"
"\n"
"\n"
"// Samples a normal from Visible Normal Distribution as described in\n"
"// [1] \"A Simpler and Exact Sampling Routine for the GGX Distribution of Visible Normals\" (2017) by Eric Heitz\n"
"//     https://hal.archives-ouvertes.fr/hal-01509746/document\n"
"// [2] \"Sampling the GGX Distribution of Visible Normals\" (2018) by Eric Heitz\n"
"//     https://jcgt.org/published/0007/04/01/\n"
"//\n"
"// Notes:\n"
"//      - View direction must be pointing away from the surface.\n"
"//      - Returned normal is in tangent space with Z up.\n"
"//      - Returned normal should be used to reflect the view direction and obtain\n"
"//        the sampling direction.\n"
"FLOAT3 SmithGGXSampleVisibleNormal(FLOAT3 View, // View direction in tangent space\n"
"                                   FLOAT  ax,   // X roughness\n"
"                                   FLOAT  ay,   // Y roughness\n"
"                                   FLOAT  u1,   // Uniform random variable in [0, 1]\n"
"                                   FLOAT  u2    // Uniform random variable in [0, 1]\n"
")\n"
"{\n"
"    // Stretch the view vector so we are sampling as if roughness==1\n"
"    FLOAT3 V = normalize(View * FLOAT3(ax, ay, _1f));\n"
"\n"
"#if 1\n"
"    // Technique from [1]\n"
"    // Note: while [2] claims to provide a better parameterization, it produces\n"
"    //       subjectively noisier images, so we will stick with method from [1].\n"
"\n"
"    // Build an orthonormal basis with V, T1, and T2\n"
"    FLOAT3 T1 = (V.z < FLOAT(0.999)) ? normalize(cross(V, FLOAT3(0.0, 0.0, 1.0))) : FLOAT3(1.0, 0.0, 0.0);\n"
"    FLOAT3 T2 = cross(T1, V);\n"
"\n"
"    // Choose a point on a disk with each half of the disk weighted\n"
"    // proportionally to its projection onto direction V\n"
"    FLOAT a = _1f / (_1f + V.z);\n"
"    FLOAT r = sqrt(u1);\n"
"    FLOAT phi = (u2 < a) ? (u2 / a) * PI : PI + (u2 - a) / (_1f - a) * PI;\n"
"    FLOAT p1 = r * cos(phi);\n"
"    FLOAT p2 = r * sin(phi) * ((u2 < a) ? _1f : V.z);\n"
"#else\n"
"    // Technique from [2]\n"
"    // Note: [1] uses earlier parameterization that cannot be used with view directions located in the lower\n"
"    //       hemisphere (View.z < 0). Though this is not a problem for classic microfacet BSDF models,\n"
"    //       [2] provides a better approximation that is not subject to this limitation.\n"
"\n"
"    // Build orthonormal basis (with special case if cross product is zero) (Section 4.1)\n"
"    FLOAT lensq = dot(V.xy, V.xy);\n"
"    FLOAT3 T1 = lensq > _0f ? FLOAT3(-V.y, V.x, _0f) / sqrt(lensq) : FLOAT3(1.0, 0.0, 0.0);\n"
"    FLOAT3 T2 = cross(V, T1);\n"
"\n"
"    // Sample the projected area (Section 4.2)\n"
"    FLOAT r   = sqrt(u1);\n"
"    FLOAT phi = _2f * PI * u2;\n"
"    FLOAT p1 = r * cos(phi);\n"
"    FLOAT p2 = r * sin(phi);\n"
"    FLOAT s  = FLOAT(0.5) * (_1f + V.z);\n"
"    p2 = (_1f - s) * sqrt(_1f - p1 * p1) + s * p2;\n"
"#endif\n"
"\n"
"    // Calculate the normal in the stretched tangent space\n"
"    FLOAT3 N = p1 * T1 + p2 * T2 + sqrt(max(_0f, _1f - p1 * p1 - p2 * p2)) * V;\n"
"\n"
"    // Transform the normal back to the ellipsoid configuration\n"
"    return normalize(FLOAT3(ax * N.x, ay * N.y, max(_0f, N.z)));\n"
"}\n"
"\n"
"// Returns the probability of sampling direction L for the view direction V and normal N\n"
"// using the visible normals distribution.\n"
"// [1] \"Sampling the GGX Distribution of Visible Normals\" (2018) by Eric Heitz\n"
"// https://jcgt.org/published/0007/04/01/\n"
"FLOAT SmithGGXSampleDirectionPDF(FLOAT3 V, FLOAT3 N, FLOAT3 L, FLOAT AlphaRoughness)\n"
"{\n"
"    // Micronormal is the halfway vector\n"
"    FLOAT3 H = normalize(V + L);\n"
"\n"
"    FLOAT NdotH = dot(H, N);\n"
"    FLOAT NdotV = dot(N, V);\n"
"    FLOAT NdotL = dot(N, L);\n"
"    //FLOAT VdotH = dot(V, H);\n"
"    if (NdotH <= _0f || NdotV <= _0f || NdotL <= _0f)\n"
"        return _0f;\n"
"\n"
"    // Note that [1] uses notation N for the micronormal, but in our case N is the macronormal,\n"
"    // while micronormal is H (aka the halfway vector).\n"
"    FLOAT NDF = NormalDistribution_GGX(NdotH, AlphaRoughness); // (1) - D(N)\n"
"    FLOAT G1  = SmithGGXMasking(NdotV, AlphaRoughness);        // (2) - G1(V)\n"
"\n"
"    FLOAT VNDF = G1 /* * VdotH */ * NDF / NdotV; // (3) - Dv(N)\n"
"    return  VNDF / (FLOAT(4.0) /* * VdotH */); // (17) - VdotH cancels out\n"
"}\n"
"\n"
"struct AngularInfo\n"
"{\n"
"    FLOAT NdotL; // cos angle between normal and light direction\n"
"    FLOAT NdotV; // cos angle between normal and view direction\n"
"    FLOAT NdotH; // cos angle between normal and half vector\n"
"    FLOAT LdotH; // cos angle between light direction and half vector\n"
"    FLOAT VdotH; // cos angle between view direction and half vector\n"
"};\n"
"\n"
"AngularInfo GetAngularInfo(FLOAT3 PointToLight, FLOAT3 Normal, FLOAT3 View)\n"
"{\n"
"    FLOAT3 n = normalize(Normal);       // Outward direction of surface point\n"
"    FLOAT3 v = normalize(View);         // Direction from surface point to camera\n"
"    FLOAT3 l = normalize(PointToLight); // Direction from surface point to light\n"
"    FLOAT3 h = normalize(l + v);        // Direction of the vector between l and v\n"
"\n"
"    AngularInfo info;\n"
"    info.NdotL = clamp(dot(n, l), _0f, _1f);\n"
"    info.NdotV = clamp(dot(n, v), _0f, _1f);\n"
"    info.NdotH = clamp(dot(n, h), _0f, _1f);\n"
"    info.LdotH = clamp(dot(l, h), _0f, _1f);\n"
"    info.VdotH = clamp(dot(v, h), _0f, _1f);\n"
"\n"
"    return info;\n"
"}\n"
"\n"
"struct SurfaceReflectanceInfo\n"
"{\n"
"    FLOAT  PerceptualRoughness;\n"
"    FLOAT3 Reflectance0;\n"
"    FLOAT3 Reflectance90;\n"
"    FLOAT3 DiffuseColor;\n"
"};\n"
"\n"
"// BRDF with Lambertian diffuse term and Smith-GGX specular term.\n"
"void SmithGGX_BRDF(in FLOAT3                 PointToLight,\n"
"                   in FLOAT3                 Normal,\n"
"                   in FLOAT3                 View,\n"
"                   in SurfaceReflectanceInfo SrfInfo,\n"
"                   out FLOAT3                DiffuseContrib,\n"
"                   out FLOAT3                SpecContrib,\n"
"                   out FLOAT                 NdotL)\n"
"{\n"
"    AngularInfo angularInfo = GetAngularInfo(PointToLight, Normal, View);\n"
"\n"
"    DiffuseContrib = FLOAT3(0.0, 0.0, 0.0);\n"
"    SpecContrib    = FLOAT3(0.0, 0.0, 0.0);\n"
"    NdotL          = angularInfo.NdotL;\n"
"    // If one of the dot products is larger than zero, no division by zero can happen. Avoids black borders.\n"
"    if (angularInfo.NdotL > _0f || angularInfo.NdotV > _0f)\n"
"    {\n"
"        //           D(h,a) * G2(v,l,a) * F(v,h,f0)\n"
"        // f(v,l) = -------------------------------- = D(h,a) * Vis(v,l,a) * F(v,h,f0)\n"
"        //               4 * (n,v) * (n,l)\n"
"        // where\n"
"        //\n"
"        // Vis(v,l,a) = G2(v,l,a) / (4 * (n,v) * (n,l))\n"
"\n"
"        // It is not a mistake that AlphaRoughness = PerceptualRoughness ^ 2 and that\n"
"        // SmithGGXVisibilityCorrelated and NormalDistribution_GGX then use a2 = AlphaRoughness ^ 2.\n"
"        // See eq. 3 in https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n"
"        FLOAT  AlphaRoughness = SrfInfo.PerceptualRoughness * SrfInfo.PerceptualRoughness;\n"
"        FLOAT  D   = NormalDistribution_GGX(angularInfo.NdotH, AlphaRoughness);\n"
"        FLOAT  Vis = SmithGGXVisibilityCorrelated(angularInfo.NdotL, angularInfo.NdotV, AlphaRoughness);\n"
"        FLOAT3 F   = SchlickReflection(angularInfo.VdotH, SrfInfo.Reflectance0, SrfInfo.Reflectance90);\n"
"\n"
"        DiffuseContrib = (_1f - F) * LambertianDiffuse(SrfInfo.DiffuseColor);\n"
"        SpecContrib    = F * Vis * D;\n"
"    }\n"
"}\n"
"\n"
"#endif // _PBR_COMMON_FXH_\n"
