"#include \"ScreenSpaceReflectionStructures.fxh\"\n"
"#include \"SSR_Common.fxh\"\n"
"\n"
"#pragma warning(disable : 3078)\n"
"\n"
"cbuffer cbScreenSpaceReflectionAttribs\n"
"{\n"
"    ScreenSpaceReflectionAttribs g_SSRAttribs;\n"
"}\n"
"\n"
"Texture2D<float2> g_TextureMotion;\n"
"Texture2D<float>  g_TextureRoughness;\n"
"Texture2D<float>  g_TextureHitDepth;\n"
"\n"
"Texture2D<float>  g_TextureCurrDepth;\n"
"Texture2D<float4> g_TextureCurrRadiance;\n"
"Texture2D<float>  g_TextureCurrVariance;\n"
"\n"
"Texture2D<float>  g_TexturePrevDepth;\n"
"Texture2D<float4> g_TexturePrevRadiance;\n"
"Texture2D<float>  g_TexturePrevVariance;\n"
"\n"
"SamplerState g_TexturePrevDepth_sampler;\n"
"SamplerState g_TexturePrevRadiance_sampler;\n"
"SamplerState g_TexturePrevVariance_sampler;\n"
"\n"
"struct ProjectionDesc\n"
"{\n"
"    float4 Color;\n"
"    float2 PrevCoord;\n"
"    bool IsSuccess;\n"
"};\n"
"\n"
"struct PixelStatistic\n"
"{\n"
"    float4 Mean;\n"
"    float4 Variance;\n"
"    float4 StdDev;\n"
"};\n"
"\n"
"struct PSOutput\n"
"{\n"
"    float4 Radiance : SV_Target0;\n"
"    float  Variance : SV_Target1;\n"
"};\n"
"\n"
"float2 SampleMotion(int2 PixelCoord)\n"
"{\n"
"    return g_TextureMotion.Load(int3(PixelCoord, 0)) * F3NDC_XYZ_TO_UVD_SCALE.xy;\n"
"}\n"
"\n"
"float SampleCurrDepth(int2 PixelCoord)\n"
"{\n"
"    return g_TextureCurrDepth.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SamplePrevDepth(int2 PixelCoord)\n"
"{\n"
"    return g_TexturePrevDepth.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SampleHitDepth(int2 PixelCoord)\n"
"{\n"
"    return g_TextureHitDepth.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SampleRoughness(int2 PixelCoord)\n"
"{\n"
"    return g_TextureRoughness.Load(int3(PixelCoord, 0));;\n"
"}\n"
"\n"
"float4 SampleCurrRadiance(int2 PixelCoord)\n"
"{\n"
"    return g_TextureCurrRadiance.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SampleCurrVariance(int2 PixelCoord)\n"
"{\n"
"    return g_TextureCurrVariance.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float4 SamplePrevRadiance(int2 PixelCoord)\n"
"{\n"
"    return g_TexturePrevRadiance.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SamplePrevVariance(int2 PixelCoord)\n"
"{\n"
"    return g_TexturePrevVariance.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SamplePrevDepthLinear(float2 PixelCoord)\n"
"{\n"
"    float2 Texcoord = PixelCoord * g_SSRAttribs.InverseRenderSize;\n"
"    return g_TexturePrevDepth.SampleLevel(g_TexturePrevDepth_sampler, Texcoord, 0);\n"
"}\n"
"\n"
"float4 SamplePrevRadianceLinear(float2 PixelCoord)\n"
"{\n"
"    float2 Texcoord = PixelCoord * g_SSRAttribs.InverseRenderSize;\n"
"    return g_TexturePrevRadiance.SampleLevel(g_TexturePrevRadiance_sampler, Texcoord, 0);\n"
"}\n"
"\n"
"float SamplePrevVarianceLinear(float2 PixelCoord)\n"
"{\n"
"    float2 Texcoord = PixelCoord * g_SSRAttribs.InverseRenderSize;\n"
"    return g_TexturePrevVariance.SampleLevel(g_TexturePrevVariance_sampler, Texcoord, 0);\n"
"}\n"
"\n"
"float2 ComputeReflectionHitPosition(int2 PixelCoord, float Depth)\n"
"{\n"
"    float2 UV = (float2(PixelCoord) + 0.5) * g_SSRAttribs.InverseRenderSize;\n"
"    float3 PositionWS = InvProjectPosition(float3(UV, Depth), g_SSRAttribs.InvViewProjMatrix);\n"
"    float3 PrevCoordUV = ProjectPosition(PositionWS, g_SSRAttribs.PrevViewProjMatrix);\n"
"    return PrevCoordUV.xy * float2(g_SSRAttribs.RenderSize);\n"
"}\n"
"\n"
"// TODO: Use normals to compute disocclusion\n"
"float ComputeDisocclusion(float CurrDepth, float PrevDepth)\n"
"{\n"
"    float LinearDepthCurr = DepthToCameraZ(CurrDepth, g_SSRAttribs.ProjMatrix);\n"
"    float LinearDepthPrev = DepthToCameraZ(PrevDepth, g_SSRAttribs.ProjMatrix);\n"
"    return exp(-abs(LinearDepthPrev - LinearDepthCurr) / LinearDepthCurr * SSR_DISOCCLUSION_DEPTH_WEIGHT);\n"
"}\n"
"\n"
"// Welford\'s online algorithm:\n"
"//  https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n"
"PixelStatistic ComputePixelStatistic(int2 PixelCoord)\n"
"{\n"
"    PixelStatistic Desc;\n"
"    float4 M1 = float4(0.0, 0.0, 0.0, 0.0);\n"
"    float4 M2 = float4(0.0, 0.0, 0.0, 0.0);\n"
"    for (int x = -1; x <= 1; x++)\n"
"    {\n"
"        for (int y = -1; y <= 1; y++)\n"
"        {\n"
"            int2 Offset = int2(x, y);\n"
"            int2 Coord = int2(PixelCoord) + Offset;\n"
"            float4 SampleColor = g_TextureCurrRadiance.Load(int3(Coord, 0));\n"
"\n"
"            M1 += SampleColor;\n"
"            M2 += SampleColor * SampleColor;\n"
"        }\n"
"    }\n"
"\n"
"    Desc.Mean = M1 / 9.0;\n"
"    Desc.Variance = (M2 / 9.0) - (Desc.Mean * Desc.Mean);\n"
"    Desc.StdDev = sqrt(max(Desc.Variance, 0.0f));\n"
"    return Desc;\n"
"}\n"
"\n"
"ProjectionDesc ComputeReprojection(float2 PrevPos, float CurrDepth)\n"
"{\n"
"    ProjectionDesc Desc;\n"
"    Desc.PrevCoord = PrevPos;\n"
"    Desc.IsSuccess = ComputeDisocclusion(CurrDepth, SamplePrevDepth(int2(PrevPos))) > SSR_DISOCCLUSION_THRESHOLD;\n"
"    Desc.Color = SamplePrevRadianceLinear(Desc.PrevCoord);\n"
"\n"
"    if (!Desc.IsSuccess)\n"
"    {\n"
"        float Disocclusion = 0.0;\n"
"        const int SearchRadius = 1;\n"
"        for (int y = -SearchRadius; y <= SearchRadius; y++)\n"
"        {\n"
"            for (int x = -SearchRadius; x <= SearchRadius; x++)\n"
"            {\n"
"                float2 Location = PrevPos + float2(x, y);\n"
"                float PrevDepth = SamplePrevDepthLinear(Location);\n"
"                float Weight = ComputeDisocclusion(CurrDepth, PrevDepth);\n"
"                if (Weight > Disocclusion)\n"
"                {\n"
"                    Disocclusion = Weight;\n"
"                    Desc.PrevCoord = Location;\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        Desc.IsSuccess = Disocclusion > SSR_DISOCCLUSION_THRESHOLD;\n"
"        Desc.Color = SamplePrevRadianceLinear(Desc.PrevCoord);\n"
"    }\n"
"\n"
"    if (!Desc.IsSuccess)\n"
"    {\n"
"        int2 PrevPosi = int2(Desc.PrevCoord - 0.5);\n"
"        float x = frac(Desc.PrevCoord.x + 0.5);\n"
"        float y = frac(Desc.PrevCoord.y + 0.5);\n"
"\n"
"        float Weight[4];\n"
"        Weight[0] = (1.0 - x) * (1.0 - y);\n"
"        Weight[1] = x * (1.0 - y);\n"
"        Weight[2] = (1.0 - x) * y;\n"
"        Weight[3] = x * y;\n"
"\n"
"        for (int SampleIdx = 0; SampleIdx < 4; ++SampleIdx)\n"
"        {\n"
"            int2 Location = PrevPosi + int2(SampleIdx & 0x01, SampleIdx >> 1);\n"
"            float PrevDepth = SamplePrevDepth(Location);\n"
"            bool IsValidSample = ComputeDisocclusion(CurrDepth, PrevDepth) > (SSR_DISOCCLUSION_THRESHOLD / 2.0);\n"
"            Weight[SampleIdx] *= float(IsValidSample);\n"
"        }\n"
"\n"
"        float WeightSum = 0.0;\n"
"        float DepthSum = 0.0;\n"
"        float4 ColorSum = float4(0.0, 0.0, 0.0, 0.0);\n"
"\n"
"        for (int SampleIdx = 0; SampleIdx < 4; ++SampleIdx)\n"
"        {\n"
"            int2 Location = PrevPosi + int2(SampleIdx & 0x01, SampleIdx >> 1);\n"
"            ColorSum  += Weight[SampleIdx] * SamplePrevRadiance(Location);\n"
"            DepthSum  += Weight[SampleIdx] * SamplePrevDepth(Location);\n"
"            WeightSum += Weight[SampleIdx];\n"
"        }\n"
"        DepthSum /= max(WeightSum, 1.0e-6f);\n"
"        ColorSum /= max(WeightSum, 1.0e-6f);\n"
"\n"
"        Desc.IsSuccess = ComputeDisocclusion(CurrDepth, DepthSum) > SSR_DISOCCLUSION_THRESHOLD;\n"
"        Desc.Color = ColorSum;\n"
"    }\n"
"\n"
"    Desc.IsSuccess = Desc.IsSuccess && IsInsideScreen(int2(Desc.PrevCoord), g_SSRAttribs.RenderSize);\n"
"    return Desc;\n"
"}\n"
"\n"
"SSR_ATTRIBUTE_EARLY_DEPTH_STENCIL\n"
"PSOutput ComputeTemporalAccumulationPS(in float4 Position : SV_Position)\n"
"{\n"
"    // Secondary reprojection based on ray lengths:\n"
"    // https://www.ea.com/seed/news/seed-dd18-presentation-slides-raytracing (Slide 45)\n"
"\n"
"    PixelStatistic PixelStat = ComputePixelStatistic(int2(Position.xy));\n"
"    float Depth = SampleCurrDepth(int2(Position.xy));\n"
"    float HitDepth = SampleHitDepth(int2(Position.xy));\n"
"    float Roughness = SampleRoughness(int2(Position.xy));\n"
"    float2 Motion = SampleMotion(int2(Position.xy));\n"
"\n"
"    float2 PrevIncidentPoint = Position.xy - Motion * float2(g_SSRAttribs.RenderSize);\n"
"    float2 PrevReflectionHit = ComputeReflectionHitPosition(int2(Position.xy), HitDepth);\n"
"\n"
"    float4 PrevColorIncidentPoint = SamplePrevRadianceLinear(PrevIncidentPoint);\n"
"    float4 PrevColorReflectionHit = SamplePrevRadianceLinear(PrevReflectionHit);\n"
"\n"
"    float PrevDistanceIncidentPoint = abs(Luminance(PrevColorIncidentPoint.rgb) - Luminance(PixelStat.Mean.rgb));\n"
"    float PrevDistanceReflectionHit = abs(Luminance(PrevColorReflectionHit.rgb) - Luminance(PixelStat.Mean.rgb));\n"
"\n"
"    float2 PrevCoord = PrevDistanceIncidentPoint < PrevDistanceReflectionHit ? PrevIncidentPoint : PrevReflectionHit;\n"
"    ProjectionDesc Reprojection = ComputeReprojection(PrevCoord, Depth);\n"
"\n"
"    PSOutput Output;\n"
"    if (Reprojection.IsSuccess)\n"
"    {\n"
"        float Alpha = IsMirrorReflection(Roughness) ? 0.95 : 1.0;\n"
"        float4 ColorMin = PixelStat.Mean - SSR_TEMPORAL_STANDARD_DEVIATION_SCALE * PixelStat.StdDev;\n"
"        float4 ColorMax = PixelStat.Mean + SSR_TEMPORAL_STANDARD_DEVIATION_SCALE * PixelStat.StdDev;\n"
"        float4 PrevRadiance = clamp(Reprojection.Color, ColorMin, ColorMax);\n"
"        float  PrevVariance = SamplePrevVarianceLinear(Reprojection.PrevCoord);\n"
"        Output.Radiance = lerp(SampleCurrRadiance(int2(Position.xy)), PrevRadiance, Alpha * g_SSRAttribs.TemporalRadianceStabilityFactor);\n"
"        Output.Variance = lerp(SampleCurrVariance(int2(Position.xy)), PrevVariance, Alpha * g_SSRAttribs.TemporalVarianceStabilityFactor);\n"
"    }\n"
"    else\n"
"    {\n"
"        Output.Radiance = SampleCurrRadiance(int2(Position.xy));\n"
"        Output.Variance = 1.0f;\n"
"    }\n"
"    return Output;\n"
"}\n"
