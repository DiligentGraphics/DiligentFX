"#include \"ScreenSpaceReflectionStructures.fxh\"\n"
"#include \"SSR_Common.fxh\"\n"
"\n"
"#pragma warning(disable : 3078)\n"
"\n"
"cbuffer cbScreenSpaceReflectionAttribs\n"
"{\n"
"    ScreenSpaceReflectionAttribs g_SSRAttribs;\n"
"}\n"
"\n"
"Texture2D<float2> g_TextureMotion;\n"
"Texture2D<float>  g_TextureRoughness;\n"
"Texture2D<float>  g_TextureHitDepth;\n"
"\n"
"Texture2D<float>  g_TextureCurrDepth;\n"
"Texture2D<float4> g_TextureCurrRadiance;\n"
"Texture2D<float>  g_TextureCurrVariance;\n"
"\n"
"Texture2D<float>       g_TexturePrevDepth;\n"
"Texture2DArray<float4> g_TexturePrevRadiance;\n"
"Texture2DArray<float>  g_TexturePrevVariance;\n"
"\n"
"SamplerState g_TexturePrevDepth_sampler;\n"
"SamplerState g_TexturePrevRadiance_sampler;\n"
"SamplerState g_TexturePrevVariance_sampler;\n"
"\n"
"struct ProjectionDesc\n"
"{\n"
"    float4 Color;\n"
"    float2 PrevCoord;\n"
"    bool IsSuccess;\n"
"};\n"
"\n"
"struct PixelStatistic\n"
"{\n"
"    float4 Mean;\n"
"    float4 Variance;\n"
"    float4 StdDev;\n"
"};\n"
"\n"
"struct PSOutput\n"
"{\n"
"    float4 Radiance : SV_Target0;\n"
"    float Variance  : SV_Target1;\n"
"};\n"
"\n"
"float2 SampleMotion(uint2 PixelCoord)\n"
"{\n"
"    return g_TextureMotion.Load(int3(PixelCoord, 0)) * F3NDC_XYZ_TO_UVD_SCALE.xy;\n"
"}\n"
"\n"
"float SampleCurrDepth(uint2 PixelCoord)\n"
"{\n"
"    return g_TextureCurrDepth.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SamplePrevDepth(uint2 PixelCoord)\n"
"{\n"
"    return g_TexturePrevDepth.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SampleHitDepth(uint2 PixelCoord)\n"
"{\n"
"    return g_TextureHitDepth.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SampleRoughness(uint2 PixelCoord)\n"
"{\n"
"    return g_TextureRoughness.Load(int3(PixelCoord, 0));;\n"
"}\n"
"\n"
"float4 SampleCurrRadiance(uint2 PixelCoord)\n"
"{\n"
"    return g_TextureCurrRadiance.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SampleCurrVariance(uint2 PixelCoord)\n"
"{\n"
"    return g_TextureCurrVariance.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float4 SamplePrevRadiance(uint2 PixelCoord)\n"
"{\n"
"    return g_TexturePrevRadiance.Load(uint4(PixelCoord, 0, 0));\n"
"}\n"
"\n"
"float SamplePrevVariance(uint2 PixelCoord)\n"
"{\n"
"    return g_TexturePrevVariance.Load(uint4(PixelCoord, 0, 0));\n"
"}\n"
"\n"
"float SamplePrevDepthLinear(float2 PixelCoord)\n"
"{\n"
"    const float2 Texcoord = PixelCoord * g_SSRAttribs.InverseRenderSize;\n"
"    return g_TexturePrevDepth.SampleLevel(g_TexturePrevDepth_sampler, float2(Texcoord), 0);\n"
"}\n"
"\n"
"float4 SamplePrevRadianceLinear(float2 PixelCoord)\n"
"{\n"
"    const float2 Texcoord = PixelCoord * g_SSRAttribs.InverseRenderSize;\n"
"    return g_TexturePrevRadiance.SampleLevel(g_TexturePrevRadiance_sampler, float3(Texcoord, 0), 0);\n"
"}\n"
"\n"
"float SamplePrevVarianceLinear(float2 PixelCoord)\n"
"{\n"
"    const float2 Texcoord = PixelCoord * g_SSRAttribs.InverseRenderSize;\n"
"    return g_TexturePrevVariance.SampleLevel(g_TexturePrevVariance_sampler, float3(Texcoord, 0), 0);\n"
"}\n"
"\n"
"float2 ComputeReflectionHitPosition(uint2 PixelCoord, float Depth)\n"
"{\n"
"    const float2 UV = (float2(PixelCoord) + 0.5) * g_SSRAttribs.InverseRenderSize;\n"
"    const float3 PositionWS = InvProjectPosition(float3(UV, Depth), g_SSRAttribs.InvViewProjMatrix);\n"
"    const float3 PrevCoordUV = ProjectPosition(PositionWS, g_SSRAttribs.PrevViewProjMatrix);\n"
"    return PrevCoordUV.xy * g_SSRAttribs.RenderSize;\n"
"}\n"
"\n"
"// TODO: Use normals to compute disocclusion\n"
"float ComputeDisocclusion(float CurrDepth, float PrevDepth)\n"
"{\n"
"    const float LinearDepthCurr = DepthToCameraZ(CurrDepth, g_SSRAttribs.ProjMatrix);\n"
"    const float LinearDepthPrev = DepthToCameraZ(PrevDepth, g_SSRAttribs.ProjMatrix);\n"
"    return exp(-abs(LinearDepthPrev - LinearDepthCurr) / LinearDepthCurr * SSR_DISOCCLUSION_DEPTH_WEIGHT);\n"
"}\n"
"\n"
"// Welford\'s online algorithm:\n"
"//  https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n"
"PixelStatistic ComputePixelStatistic(uint2 PixelCoord)\n"
"{\n"
"    PixelStatistic Desc;\n"
"    float4 M1 = float4(0.0, 0.0, 0.0, 0.0);\n"
"    float4 M2 = float4(0.0, 0.0, 0.0, 0.0);\n"
"    for (int x = -1; x <= 1; x++)\n"
"    {\n"
"        for (int y = -1; y <= 1; y++)\n"
"        {\n"
"            const int2 Offset = int2(x, y);\n"
"            const int2 Coord = int2(PixelCoord) + Offset;\n"
"            const float4 SampleColor = g_TextureCurrRadiance.Load(int3(Coord, 0));\n"
"\n"
"            M1 += SampleColor;\n"
"            M2 += SampleColor * SampleColor;\n"
"        }\n"
"    }\n"
"\n"
"    Desc.Mean = M1 / 9.0;\n"
"    Desc.Variance = (M2 / 9.0) - (Desc.Mean * Desc.Mean);\n"
"    Desc.StdDev = sqrt(max(Desc.Variance, 0.0f));\n"
"    return Desc;\n"
"}\n"
"\n"
"ProjectionDesc ComputeReprojection(float2 PrevPos, float CurrDepth)\n"
"{\n"
"    ProjectionDesc Desc;\n"
"    Desc.PrevCoord = PrevPos;\n"
"    Desc.IsSuccess = ComputeDisocclusion(CurrDepth, SamplePrevDepth(int2(PrevPos))) > SSR_DISOCCLUSION_THRESHOLD;\n"
"    Desc.Color = SamplePrevRadianceLinear(Desc.PrevCoord);\n"
"\n"
"    if (!Desc.IsSuccess)\n"
"    {\n"
"        float Disocclusion = 0.0;\n"
"        const int SearchRadius = 1;\n"
"        for (int y = -SearchRadius; y <= SearchRadius; y++)\n"
"        {\n"
"            for (int x = -SearchRadius; x <= SearchRadius; x++)\n"
"            {\n"
"                const float2 Location = PrevPos + int2(x, y);\n"
"                const float PrevDepth = SamplePrevDepthLinear(Location);\n"
"                const float Weight = ComputeDisocclusion(CurrDepth, PrevDepth);\n"
"                if (Weight > Disocclusion)\n"
"                {\n"
"                    Disocclusion = Weight;\n"
"                    Desc.PrevCoord = Location;\n"
"                }\n"
"            }\n"
"        }\n"
"\n"
"        Desc.IsSuccess = Disocclusion > SSR_DISOCCLUSION_THRESHOLD;\n"
"        Desc.Color = SamplePrevRadianceLinear(Desc.PrevCoord);\n"
"    }\n"
"\n"
"    if (!Desc.IsSuccess)\n"
"    {\n"
"        const int2 Offset[4] = { int2(0, 0), int2(1, 0), int2(0, 1), int2(1, 1) };\n"
"        const int2 PrevPosi = int2(Desc.PrevCoord - 0.5);\n"
"        const float x = frac(Desc.PrevCoord.x + 0.5);\n"
"        const float y = frac(Desc.PrevCoord.y + 0.5);\n"
"        float Weight[4] = { (1 - x) * (1 - y), x * (1 - y), (1 - x) * y, x * y };\n"
"        for (uint SampleIdx = 0; SampleIdx < 4; SampleIdx++)\n"
"        {\n"
"            const int2 Location = PrevPosi + Offset[SampleIdx];\n"
"            const float PrevDepth = SamplePrevDepth(Location);\n"
"            const bool IsValidSample = ComputeDisocclusion(CurrDepth, PrevDepth) > (SSR_DISOCCLUSION_THRESHOLD / 2);\n"
"            Weight[SampleIdx] *= float(IsValidSample);\n"
"        }\n"
"\n"
"        float WeightSum = 0;\n"
"        float DepthSum = 0.0;\n"
"        float4 ColorSum = float4(0.0, 0.0, 0.0, 0.0);\n"
"\n"
"        for (uint SampleIdx = 0; SampleIdx < 4; SampleIdx++)\n"
"        {\n"
"            const int2 Location = PrevPosi + Offset[SampleIdx];\n"
"            ColorSum  += Weight[SampleIdx] * SamplePrevRadiance(Location);\n"
"            DepthSum  += Weight[SampleIdx] * SamplePrevDepth(Location);\n"
"            WeightSum += Weight[SampleIdx];\n"
"        }\n"
"        DepthSum /= max(WeightSum, 1.0e-6f);\n"
"        ColorSum /= max(WeightSum, 1.0e-6f);\n"
"\n"
"        Desc.IsSuccess = ComputeDisocclusion(CurrDepth, DepthSum) > SSR_DISOCCLUSION_THRESHOLD;\n"
"        Desc.Color = ColorSum;\n"
"    }\n"
"\n"
"    Desc.IsSuccess = Desc.IsSuccess && IsInsideScreen(int2(Desc.PrevCoord), g_SSRAttribs.RenderSize);\n"
"    return Desc;\n"
"}\n"
"\n"
"SSR_ATTRIBUTE_EARLY_DEPTH_STENCIL\n"
"PSOutput ComputeTemporalAccumulationPS(in float4 Position : SV_Position)\n"
"{\n"
"    // Secondary reprojection based on ray lengths:\n"
"    // https://www.ea.com/seed/news/seed-dd18-presentation-slides-raytracing (Slide 45)\n"
"\n"
"    const PixelStatistic PixelStat = ComputePixelStatistic(uint2(Position.xy));\n"
"    const float Depth = SampleCurrDepth(uint2(Position.xy));\n"
"    const float HitDepth = SampleHitDepth(uint2(Position.xy));\n"
"    const float2 Motion = SampleMotion(uint2(Position.xy));\n"
"    const float Roughness = SampleRoughness(uint2(Position.xy));\n"
"\n"
"    const float2 PrevIncidentPoint = Position.xy - Motion * g_SSRAttribs.RenderSize;\n"
"    const float2 PrevReflectionHit = ComputeReflectionHitPosition(uint2(Position.xy), HitDepth);\n"
"\n"
"    const float4 PrevColorIncidentPoint = SamplePrevRadianceLinear(PrevIncidentPoint);\n"
"    const float4 PrevColorReflectionHit = SamplePrevRadianceLinear(PrevReflectionHit);\n"
"\n"
"    const float PrevDistanceIncidentPoint = abs(Luminance(PrevColorIncidentPoint.rgb) - Luminance(PixelStat.Mean.rgb));\n"
"    const float PrevDistanceReflectionHit = abs(Luminance(PrevColorReflectionHit.rgb) - Luminance(PixelStat.Mean.rgb));\n"
"\n"
"    const float2 PrevCoord = PrevDistanceIncidentPoint < PrevDistanceReflectionHit ? PrevIncidentPoint : PrevReflectionHit;\n"
"    const ProjectionDesc Reprojection = ComputeReprojection(PrevCoord, Depth);\n"
"\n"
"    PSOutput Output;\n"
"    if (Reprojection.IsSuccess)\n"
"    {\n"
"        const float Alpha = IsMirrorReflection(Roughness) ? 0.95 : 1.0;\n"
"        const float4 ColorMin = PixelStat.Mean - SSR_TEMPORAL_STANDARD_DEVIATION_SCALE * PixelStat.StdDev;\n"
"        const float4 ColorMax = PixelStat.Mean + SSR_TEMPORAL_STANDARD_DEVIATION_SCALE * PixelStat.StdDev;\n"
"        const float4 PrevRadiance = clamp(Reprojection.Color, ColorMin, ColorMax);\n"
"        const float  PrevVariance = SamplePrevVarianceLinear(Reprojection.PrevCoord);\n"
"        Output.Radiance = lerp(SampleCurrRadiance(uint2(Position.xy)), PrevRadiance, Alpha * g_SSRAttribs.TemporalRadianceStabilityFactor);\n"
"        Output.Variance = lerp(SampleCurrVariance(uint2(Position.xy)), PrevVariance, Alpha * g_SSRAttribs.TemporalVarianceStabilityFactor);\n"
"    }\n"
"    else\n"
"    {\n"
"        Output.Radiance = SampleCurrRadiance(uint2(Position.xy));\n"
"        Output.Variance = 1.0f;\n"
"    }\n"
"    return Output;\n"
"}\n"
