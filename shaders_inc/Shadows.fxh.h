"#ifndef _SHADOWS_FXH_\n"
"#define _SHADOWS_FXH_\n"
"\n"
"// Must include BasicStructures.fxh\n"
"\n"
"#ifndef SHADOW_FILTER_SIZE\n"
"#   define SHADOW_FILTER_SIZE 2\n"
"#endif\n"
"\n"
"#ifndef FILTER_ACROSS_CASCADES\n"
"#   define FILTER_ACROSS_CASCADES 0\n"
"#endif\n"
"\n"
"void FindCascade(ShadowMapAttribs ShadowAttribs,\n"
"                 float3           f3PosInLightViewSpace,\n"
"                 float            fCameraViewSpaceZ,\n"
"                 out float3       f3PosInCascadeProjSpace,\n"
"                 out float3       f3CascadeLightSpaceScale,\n"
"                 out int          iCascadeIdx,\n"
"                 out float        fMinDistToEdge)\n"
"{\n"
"    f3PosInCascadeProjSpace  = float3(0.0, 0.0, 0.0);\n"
"    f3CascadeLightSpaceScale = float3(0.0, 0.0, 0.0);\n"
"    iCascadeIdx = 0;\n"
"    fMinDistToEdge = 0.0;\n"
"#if BEST_CASCADE_SEARCH\n"
"    while (iCascadeIdx < ShadowAttribs.iNumCascades)\n"
"    {\n"
"        // Find the smallest cascade which covers current point\n"
"        CascadeAttribs Cascade = ShadowAttribs.Cascades[iCascadeIdx];\n"
"        f3CascadeLightSpaceScale = Cascade.f4LightSpaceScale.xyz;\n"
"        f3PosInCascadeProjSpace = f3PosInLightViewSpace * f3CascadeLightSpaceScale + ShadowAttribs.Cascades[iCascadeIdx].f4LightSpaceScaledBias.xyz;\n"
"        float4 f4MaxFilterRadiusProjSpace = Cascade.f4MaxFilterRadiusProjSpace;\n"
"\n"
"        float4 f4DistToEdges;\n"
"        f4DistToEdges.xy = float2(1.0, 1.0) - f4MaxFilterRadiusProjSpace.xy - abs(f3PosInCascadeProjSpace.xy);\n"
"        const float ZScale = 2.0 / (1.0 - NDC_MIN_Z);\n"
"        f4DistToEdges.z = (f3PosInCascadeProjSpace.z - (NDC_MIN_Z + f4MaxFilterRadiusProjSpace.z)) * ZScale;\n"
"        f4DistToEdges.w = (1.0 - f4MaxFilterRadiusProjSpace.w - f3PosInCascadeProjSpace.z) * ZScale;\n"
"        fMinDistToEdge = min(min(f4DistToEdges.x, f4DistToEdges.y), min(f4DistToEdges.z, f4DistToEdges.w));\n"
"\n"
"        if(fMinDistToEdge > 0.0)\n"
"            break;\n"
"        else\n"
"            iCascadeIdx++;\n"
"    }\n"
"#else\n"
"    [unroll]\n"
"    for(int i=0; i< (ShadowAttribs.iNumCascades+3)/4; ++i)\n"
"    {\n"
"        float4 f4CascadeZEnd = ShadowAttribs.f4CascadeCamSpaceZEnd[i];\n"
"        float4 v = float4( f4CascadeZEnd.x < fCameraViewSpaceZ ? 1.0 : 0.0, \n"
"                           f4CascadeZEnd.y < fCameraViewSpaceZ ? 1.0 : 0.0,\n"
"                           f4CascadeZEnd.z < fCameraViewSpaceZ ? 1.0 : 0.0,\n"
"                           f4CascadeZEnd.w < fCameraViewSpaceZ ? 1.0 : 0.0);\n"
"	    //float4 v = float4(ShadowAttribs.f4CascadeCamSpaceZEnd[i] < fCameraViewSpaceZ);\n"
"	    iCascadeIdx += int(dot(float4(1.0,1.0,1.0,1.0), v));\n"
"    }\n"
"    if( iCascadeIdx < ShadowAttribs.iNumCascades )\n"
"    {\n"
"        //Cascade = min(Cascade, ShadowAttribs.iNumCascades - 1);\n"
"        CascadeAttribs Cascade = ShadowAttribs.Cascades[iCascadeIdx];\n"
"        f3CascadeLightSpaceScale = Cascade.f4LightSpaceScale.xyz;\n"
"        f3PosInCascadeProjSpace = f3PosInLightViewSpace * f3CascadeLightSpaceScale + Cascade.f4LightSpaceScaledBias.xyz;\n"
"        fMinDistToEdge = (Cascade.f4StartEndZ.y - fCameraViewSpaceZ) / (Cascade.f4StartEndZ.y - Cascade.f4StartEndZ.x);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"float2 ComputeReceiverPlaneDepthBias(float3 ShadowUVDepthDX,\n"
"                                     float3 ShadowUVDepthDY)\n"
"{    \n"
"    // Compute (dDepth/dU, dDepth/dV):\n"
"    //  \n"
"    //  | dDepth/dU |    | dX/dU    dX/dV |T  | dDepth/dX |     | dU/dX    dU/dY |-1T | dDepth/dX |\n"
"    //                 =                                     =                                      =\n"
"    //  | dDepth/dV |    | dY/dU    dY/dV |   | dDepth/dY |     | dV/dX    dV/dY |    | dDepth/dY |\n"
"    //\n"
"    //  | A B |-1   | D  -B |                      | A B |-1T   | D  -C |                                   \n"
"    //            =           / det                           =           / det                    \n"
"    //  | C D |     |-C   A |                      | C D |      |-B   A |\n"
"    //\n"
"    //  | dDepth/dU |           | dV/dY   -dV/dX |  | dDepth/dX |\n"
"    //                 = 1/det                                       \n"
"    //  | dDepth/dV |           |-dU/dY    dU/dX |  | dDepth/dY |\n"
"\n"
"    float2 biasUV;\n"
"    //               dV/dY       V      dDepth/dX    D       dV/dX       V     dDepth/dY     D\n"
"    biasUV.x =   ShadowUVDepthDY.y * ShadowUVDepthDX.z - ShadowUVDepthDX.y * ShadowUVDepthDY.z;\n"
"    //               dU/dY       U      dDepth/dX    D       dU/dX       U     dDepth/dY     D\n"
"    biasUV.y = - ShadowUVDepthDY.x * ShadowUVDepthDX.z + ShadowUVDepthDX.x * ShadowUVDepthDY.z;\n"
"\n"
"    float Det = (ShadowUVDepthDX.x * ShadowUVDepthDY.y) - (ShadowUVDepthDX.y * ShadowUVDepthDY.x);\n"
"	biasUV /= sign(Det) * max( abs(Det), 1e-10 );\n"
"    //biasUV = abs(Det) > 1e-7 ? biasUV / abs(Det) : 0;// sign(Det) * max( abs(Det), 1e-10 );\n"
"    return biasUV;\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"//-------------------------------------------------------------------------------------------------\n"
"// The method used in The Witness\n"
"//-------------------------------------------------------------------------------------------------\n"
"float FilterShadowMapOptimizedPCF(in Texture2DArray<float>  tex2DShadowMap,\n"
"                                  in SamplerComparisonState tex2DShadowMap_sampler,\n"
"                                  in float4                 shadowMapSize,\n"
"                                  in float3                 shadowPos,\n"
"                                  in int                    cascadeIdx,\n"
"                                  in float2                 receiverPlaneDepthBias)\n"
"{\n"
"    float lightDepth = shadowPos.z;\n"
"\n"
"    float2 uv = shadowPos.xy * shadowMapSize.xy;\n"
"    float2 base_uv = floor(uv + float2(0.5, 0.5));\n"
"    float s = (uv.x + 0.5 - base_uv.x);\n"
"    float t = (uv.y + 0.5 - base_uv.y);\n"
"    base_uv -= float2(0.5, 0.5);\n"
"    base_uv *= shadowMapSize.zw;\n"
"\n"
"    float sum = 0;\n"
"\n"
"    // It is essential to clamp biased depth to 0 to avoid shadow leaks at near cascade depth boundary.\n"
"    //        \n"
"    //            No clamping                 With clamping\n"
"    //                                      \n"
"    //              \\ |                             ||    \n"
"    //       ==>     \\|                             ||\n"
"    //                |                             ||         \n"
"    // Light ==>      |\\                            |\\         \n"
"    //                | \\Receiver plane             | \\ Receiver plane\n"
"    //       ==>      |  \\                          |  \\   \n"
"    //                0   ...   1                   0   ...   1\n"
"    //\n"
"    // Note that clamping at far depth boundary makes no difference as 1 < 1 produces 0 and so does 1+x < 1\n"
"    const float DepthClamp = 1e-8;\n"
"#define SAMPLE_SHADOW_MAP(u, v) tex2DShadowMap.SampleCmp(tex2DShadowMap_sampler, float3(base_uv.xy + float2(u,v) * shadowMapSize.zw, cascadeIdx), max(lightDepth + dot(float2(u, v), receiverPlaneDepthBias), DepthClamp))\n"
"\n"
"    #if SHADOW_FILTER_SIZE == 2\n"
"\n"
"        return tex2DShadowMap.SampleCmp(tex2DShadowMap_sampler, float3(shadowPos.xy, cascadeIdx), max(lightDepth, DepthClamp));\n"
"\n"
"    #elif SHADOW_FILTER_SIZE == 3\n"
"\n"
"        float uw0 = (3.0 - 2.0 * s);\n"
"        float uw1 = (1.0 + 2.0 * s);\n"
"\n"
"        float u0 = (2.0 - s) / uw0 - 1.0;\n"
"        float u1 = s / uw1 + 1.0;\n"
"\n"
"        float vw0 = (3.0 - 2.0 * t);\n"
"        float vw1 = (1.0 + 2.0 * t);\n"
"\n"
"        float v0 = (2.0 - t) / vw0 - 1;\n"
"        float v1 = t / vw1 + 1;\n"
"\n"
"        sum += uw0 * vw0 * SAMPLE_SHADOW_MAP(u0, v0);\n"
"        sum += uw1 * vw0 * SAMPLE_SHADOW_MAP(u1, v0);\n"
"        sum += uw0 * vw1 * SAMPLE_SHADOW_MAP(u0, v1);\n"
"        sum += uw1 * vw1 * SAMPLE_SHADOW_MAP(u1, v1);\n"
"\n"
"        return sum * 1.0 / 16.0;\n"
"\n"
"    #elif SHADOW_FILTER_SIZE == 5\n"
"\n"
"        float uw0 = (4.0 - 3.0 * s);\n"
"        float uw1 = 7.0;\n"
"        float uw2 = (1.0 + 3.0 * s);\n"
"\n"
"        float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n"
"        float u1 = (3.0 + s) / uw1;\n"
"        float u2 = s / uw2 + 2.0;\n"
"\n"
"        float vw0 = (4.0 - 3.0 * t);\n"
"        float vw1 = 7.0;\n"
"        float vw2 = (1.0 + 3.0 * t);\n"
"\n"
"        float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n"
"        float v1 = (3.0 + t) / vw1;\n"
"        float v2 = t / vw2 + 2;\n"
"\n"
"        sum += uw0 * vw0 * SAMPLE_SHADOW_MAP(u0, v0);\n"
"        sum += uw1 * vw0 * SAMPLE_SHADOW_MAP(u1, v0);\n"
"        sum += uw2 * vw0 * SAMPLE_SHADOW_MAP(u2, v0);\n"
"\n"
"        sum += uw0 * vw1 * SAMPLE_SHADOW_MAP(u0, v1);\n"
"        sum += uw1 * vw1 * SAMPLE_SHADOW_MAP(u1, v1);\n"
"        sum += uw2 * vw1 * SAMPLE_SHADOW_MAP(u2, v1);\n"
"\n"
"        sum += uw0 * vw2 * SAMPLE_SHADOW_MAP(u0, v2);\n"
"        sum += uw1 * vw2 * SAMPLE_SHADOW_MAP(u1, v2);\n"
"        sum += uw2 * vw2 * SAMPLE_SHADOW_MAP(u2, v2);\n"
"\n"
"        return sum * 1.0 / 144.0;\n"
"\n"
"    #elif SHADOW_FILTER_SIZE == 7\n"
"\n"
"        float uw0 = (5.0 * s - 6.0);\n"
"        float uw1 = (11.0 * s - 28.0);\n"
"        float uw2 = -(11.0 * s + 17.0);\n"
"        float uw3 = -(5.0 * s + 1.0);\n"
"\n"
"        float u0 = (4.0 * s - 5.0) / uw0 - 3.0;\n"
"        float u1 = (4.0 * s - 16.0) / uw1 - 1.0;\n"
"        float u2 = -(7.0 * s + 5.0) / uw2 + 1.0;\n"
"        float u3 = -s / uw3 + 3.0;\n"
"\n"
"        float vw0 = (5.0 * t - 6.0);\n"
"        float vw1 = (11.0 * t - 28.0);\n"
"        float vw2 = -(11.0 * t + 17.0);\n"
"        float vw3 = -(5.0 * t + 1.0);\n"
"\n"
"        float v0 = (4.0 * t - 5.0) / vw0 - 3.0;\n"
"        float v1 = (4.0 * t - 16.0) / vw1 - 1.0;\n"
"        float v2 = -(7.0 * t + 5.0) / vw2 + 1.0;\n"
"        float v3 = -t / vw3 + 3.0;\n"
"\n"
"        sum += uw0 * vw0 * SAMPLE_SHADOW_MAP(u0, v0);\n"
"        sum += uw1 * vw0 * SAMPLE_SHADOW_MAP(u1, v0);\n"
"        sum += uw2 * vw0 * SAMPLE_SHADOW_MAP(u2, v0);\n"
"        sum += uw3 * vw0 * SAMPLE_SHADOW_MAP(u3, v0);\n"
"\n"
"        sum += uw0 * vw1 * SAMPLE_SHADOW_MAP(u0, v1);\n"
"        sum += uw1 * vw1 * SAMPLE_SHADOW_MAP(u1, v1);\n"
"        sum += uw2 * vw1 * SAMPLE_SHADOW_MAP(u2, v1);\n"
"        sum += uw3 * vw1 * SAMPLE_SHADOW_MAP(u3, v1);\n"
"\n"
"        sum += uw0 * vw2 * SAMPLE_SHADOW_MAP(u0, v2);\n"
"        sum += uw1 * vw2 * SAMPLE_SHADOW_MAP(u1, v2);\n"
"        sum += uw2 * vw2 * SAMPLE_SHADOW_MAP(u2, v2);\n"
"        sum += uw3 * vw2 * SAMPLE_SHADOW_MAP(u3, v2);\n"
"\n"
"        sum += uw0 * vw3 * SAMPLE_SHADOW_MAP(u0, v3);\n"
"        sum += uw1 * vw3 * SAMPLE_SHADOW_MAP(u1, v3);\n"
"        sum += uw2 * vw3 * SAMPLE_SHADOW_MAP(u2, v3);\n"
"        sum += uw3 * vw3 * SAMPLE_SHADOW_MAP(u3, v3);\n"
"\n"
"        return sum * 1.0 / 2704.0;\n"
"    #else\n"
"        return 0.0;\n"
"    #endif\n"
"#undef SAMPLE_SHADOW_MAP\n"
"}\n"
"\n"
"float ComputeCascadeShadow(in ShadowMapAttribs       ShadowAttribs,\n"
"                           in Texture2DArray<float>  tex2DShadowMap,\n"
"                           in SamplerComparisonState tex2DShadowMap_sampler,\n"
"                           in int                    iCascadeIdx,\n"
"                           in float3                 f3PosInLightViewSpace,\n"
"                           in float3                 f3CascadeLightSpaceScale,\n"
"                           in float3                 f3PosInCascadeProjSpace)\n"
"{\n"
"    float3 f3ShadowMapUVDepth;\n"
"    f3ShadowMapUVDepth.xy = NormalizedDeviceXYToTexUV( f3PosInCascadeProjSpace.xy );\n"
"    f3ShadowMapUVDepth.z = NormalizedDeviceZToDepth( f3PosInCascadeProjSpace.z );\n"
"        \n"
"    float3 f3ddXShadowMapUVDepth = ddx(f3PosInLightViewSpace) * f3CascadeLightSpaceScale * F3NDC_XYZ_TO_UVD_SCALE;\n"
"    float3 f3ddYShadowMapUVDepth = ddy(f3PosInLightViewSpace) * f3CascadeLightSpaceScale * F3NDC_XYZ_TO_UVD_SCALE;\n"
"\n"
"    float2 f2DepthSlopeScaledBias = ComputeReceiverPlaneDepthBias(f3ddXShadowMapUVDepth, f3ddYShadowMapUVDepth);\n"
"    float2 f2SlopeScaledBiasClamp = float2(ShadowAttribs.fReceiverPlaneDepthBiasClamp, ShadowAttribs.fReceiverPlaneDepthBiasClamp);\n"
"    f2DepthSlopeScaledBias = clamp(f2DepthSlopeScaledBias, -f2SlopeScaledBiasClamp, f2SlopeScaledBiasClamp);\n"
"    f2DepthSlopeScaledBias *= ShadowAttribs.f4ShadowMapDim.zw;\n"
"\n"
"    float FractionalSamplingError = dot( float2(1.0, 1.0), abs(f2DepthSlopeScaledBias.xy) );\n"
"    FractionalSamplingError = FractionalSamplingError + ShadowAttribs.fFixedDepthBias;\n"
"    f3ShadowMapUVDepth.z -= FractionalSamplingError;\n"
"\n"
"    return FilterShadowMapOptimizedPCF(tex2DShadowMap, tex2DShadowMap_sampler, ShadowAttribs.f4ShadowMapDim, f3ShadowMapUVDepth, iCascadeIdx, f2DepthSlopeScaledBias);\n"
"}\n"
"\n"
"float ComputeShadowAmount(in ShadowMapAttribs       ShadowAttribs,\n"
"                          in Texture2DArray<float>  tex2DShadowMap,\n"
"                          in SamplerComparisonState tex2DShadowMap_sampler,\n"
"                          in float3                 f3PosInLightViewSpace,\n"
"                          in float                  fCameraSpaceZ,\n"
"                          out int                   iCascadeIdx,\n"
"                          out float                 fNextCascadeBlendAmount)\n"
"{\n"
"    float3 f3PosInCascadeProjSpace  = float3(0.0, 0.0, 0.0);\n"
"    float3 f3CascadeLightSpaceScale = float3(0.0, 0.0, 0.0);\n"
"    float  fMinDistToEdge = 0.0;\n"
"    FindCascade(ShadowAttribs, f3PosInLightViewSpace.xyz, fCameraSpaceZ, f3PosInCascadeProjSpace, f3CascadeLightSpaceScale, iCascadeIdx, fMinDistToEdge);\n"
"    if( iCascadeIdx == ShadowAttribs.iNumCascades )\n"
"        return 1.0;\n"
"\n"
"    float ShadowAmount = ComputeCascadeShadow(ShadowAttribs, tex2DShadowMap, tex2DShadowMap_sampler, iCascadeIdx, f3PosInLightViewSpace, f3CascadeLightSpaceScale, f3PosInCascadeProjSpace);\n"
"    fNextCascadeBlendAmount = 0.0;\n"
"\n"
"#if FILTER_ACROSS_CASCADES\n"
"    if (iCascadeIdx+1 < ShadowAttribs.iNumCascades)\n"
"    {\n"
"        float3 f3NextCascadeLightSpaceScale = ShadowAttribs.Cascades[iCascadeIdx+1].f4LightSpaceScale.xyz;\n"
"        float3 f3PosInNextCascadeProjSpace = f3PosInLightViewSpace * f3NextCascadeLightSpaceScale + ShadowAttribs.Cascades[iCascadeIdx+1].f4LightSpaceScaledBias.xyz;\n"
"        float NextCascadeShadow = ComputeCascadeShadow(ShadowAttribs, tex2DShadowMap, tex2DShadowMap_sampler, iCascadeIdx+1, f3PosInLightViewSpace, f3NextCascadeLightSpaceScale, f3PosInNextCascadeProjSpace);\n"
"        fNextCascadeBlendAmount = saturate(1.0 - fMinDistToEdge / ShadowAttribs.fCascadeTransitionRegion);\n"
"        ShadowAmount = lerp(ShadowAmount, NextCascadeShadow, fNextCascadeBlendAmount);\n"
"    }\n"
"#endif\n"
"\n"
"    return ShadowAmount;\n"
"}\n"
"\n"
"float3 GetCascadeColor(int Cascade, float fNextCascadeBlendAmount)\n"
"{\n"
"    float3 f3CascadeColors[MAX_CASCADES];\n"
"    f3CascadeColors[0] = float3(0,1,0);\n"
"    f3CascadeColors[1] = float3(0,0,1);\n"
"    f3CascadeColors[2] = float3(1,1,0);\n"
"    f3CascadeColors[3] = float3(0,1,1);\n"
"    f3CascadeColors[4] = float3(1,0,1);\n"
"    f3CascadeColors[5] = float3(0.3, 1, 0.7);\n"
"    f3CascadeColors[6] = float3(0.7, 0.3,1);\n"
"    f3CascadeColors[7] = float3(1, 0.7, 0.3);\n"
"    float3 Color = f3CascadeColors[min(Cascade, MAX_CASCADES-1)];\n"
"#if FILTER_ACROSS_CASCADES\n"
"    float3 NextCascadeColor = f3CascadeColors[min(Cascade+1, MAX_CASCADES-1)];\n"
"    Color = lerp(Color, NextCascadeColor, fNextCascadeBlendAmount);\n"
"#endif\n"
"    return Color;\n"
"}\n"
"\n"
"#endif //_SHADOWS_FXH_\n"
