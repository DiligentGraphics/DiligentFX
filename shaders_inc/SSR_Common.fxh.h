"#ifndef _SSR_COMMON_FXH_\n"
"#define _SSR_COMMON_FXH_\n"
"\n"
"#define M_PI                      3.14159265358979\n"
"#define M_EPSILON                 1e-3\n"
"#define M_GOLDEN_RATIO            1.61803398875\n"
"\n"
"#define FLT_EPS                   5.960464478e-8\n"
"#define FLT_MAX                   3.402823466e+38\n"
"#define FLT_MIN                   1.175494351e-38\n"
"\n"
"#if !defined(DESKTOP_GL) && !defined(GL_ES)\n"
"    #define SSR_ATTRIBUTE_EARLY_DEPTH_STENCIL [earlydepthstencil]\n"
"#else\n"
"    #define SSR_ATTRIBUTE_EARLY_DEPTH_STENCIL\n"
"#endif\n"
"\n"
"struct CRNG\n"
"{\n"
"    uint Seed;\n"
"};\n"
"\n"
"float VanDerCorputSequenceBase2(uint SampleIdx)\n"
"{\n"
"    return float(reversebits(SampleIdx)) / exp2(32.0);\n"
"}\n"
"\n"
"float2 GoldenRatioSequence(uint SampleIdx, uint N)\n"
"{\n"
"    return frac(float2((0.5 / float(N)) + float(SampleIdx) / float(N), 0.5 + rcp(M_GOLDEN_RATIO) * float(SampleIdx)));\n"
"}\n"
"\n"
"float2 HammersleySequence(uint SampleIdx, uint N)\n"
"{\n"
"    return float2(float(SampleIdx) / float(N), VanDerCorputSequenceBase2(SampleIdx));\n"
"}\n"
"\n"
"float2 VogelDiskSample(uint SampleIdx, uint N, float Phi)\n"
"{\n"
"    float GoldenAngle = 2.4;\n"
"    float R = sqrt(float(SampleIdx) + 0.5) / sqrt(float(N));\n"
"    float Theta = float(SampleIdx) * GoldenAngle + Phi;\n"
"\n"
"    float Sine, Cosine;\n"
"    sincos(Theta, Sine, Cosine);\n"
"    return float2(R * Cosine, R * Sine);\n"
"}\n"
"\n"
"float2 MapSquareToDisk(float2 Point)\n"
"{\n"
"    float Lam = sqrt(Point.x);\n"
"    float Phi = 2.0 * M_PI * Point.y;\n"
"    return float2(cos(Phi) * Lam, sin(Phi) * Lam);\n"
"}\n"
"\n"
"uint PCGHash(uint Seed)\n"
"{\n"
"    uint State = Seed * 747796405u + 2891336453u;\n"
"    uint Word = ((State >> ((State >> 28u) + 4u)) ^ State) * 277803737u;\n"
"    return (Word >> 22u) ^ Word;\n"
"}\n"
"\n"
"CRNG InitCRND(uint2 id, uint FrameIndex)\n"
"{\n"
"    CRNG Rng;\n"
"    Rng.Seed = FrameIndex + PCGHash((id.x << 16u) | id.y);\n"
"    return Rng;\n"
"}\n"
"\n"
"float Rand(inout CRNG Rng)\n"
"{\n"
"    Rng.Seed = PCGHash(Rng.Seed);\n"
"    return asfloat(0x3f800000u | (Rng.Seed >> 9u)) - 1.0;\n"
"}\n"
"\n"
"float Luminance(float3 Color)\n"
"{\n"
"    return dot(Color, float3(0.299f, 0.587f, 0.114f));\n"
"}\n"
"\n"
"float3 ProjectPosition(float3 Origin, float4x4 Transform)\n"
"{\n"
"    float4 Projected = mul(float4(Origin, 1.0), Transform);\n"
"    Projected.xyz /= Projected.w;\n"
"    Projected.xy = NormalizedDeviceXYToTexUV(Projected.xy);\n"
"    return Projected.xyz;\n"
"}\n"
"\n"
"float3 ProjectDirection(float3 Origin, float3 Direction, float3 OriginSS, float4x4 Mat)\n"
"{\n"
"    return ProjectPosition(Origin + Direction, Mat) - OriginSS;\n"
"}\n"
"\n"
"float3 InvProjectPosition(float3 Coord, float4x4 Transform)\n"
"{\n"
"    Coord.xy = TexUVToNormalizedDeviceXY(Coord.xy);\n"
"    float4 Projected = mul(float4(Coord, 1.0), Transform);\n"
"    return Projected.xyz /= Projected.w;\n"
"}\n"
"\n"
"bool IsBackground(float depth)\n"
"{\n"
"#ifdef SSR_OPTION_INVERTED_DEPTH\n"
"    return depth < 1.e-6f;\n"
"#else\n"
"    return depth >= (1.0f - 1.e-6f);\n"
"#endif // SSR_OPTION_INVERTED_DEPTH\n"
"}\n"
"\n"
"bool IsGlossyReflection(float Roughness, float RoughnessThreshold, bool IsRoughnessPerceptual)\n"
"{\n"
"    if (IsRoughnessPerceptual)\n"
"        RoughnessThreshold *= RoughnessThreshold;\n"
"    return Roughness < RoughnessThreshold;\n"
"}\n"
"\n"
"bool IsMirrorReflection(float Roughness)\n"
"{\n"
"    return Roughness < 0.0001;\n"
"}\n"
"\n"
"float DepthToCameraZ(in float fDepth, in matrix mProj)\n"
"{\n"
"    // Transformations to/from normalized device coordinates are the\n"
"    // same in both APIs.\n"
"    // However, in GL, depth must be transformed to NDC Z first\n"
"\n"
"    float z = DepthToNormalizedDeviceZ(fDepth);\n"
"    return MATRIX_ELEMENT(mProj, 3, 2) / (z - MATRIX_ELEMENT(mProj, 2, 2));\n"
"}\n"
"\n"
"float CameraZToDepth(in float fDepth, in matrix mProj)\n"
"{\n"
"    // Transformations to/from normalized device coordinates are the\n"
"    // same in both APIs.\n"
"    // However, in GL, depth must be transformed to NDC Z first\n"
"\n"
"    float z = MATRIX_ELEMENT(mProj, 3, 2) / fDepth + MATRIX_ELEMENT(mProj, 2, 2);\n"
"    return NormalizedDeviceZToDepth(z);\n"
"}\n"
"\n"
"bool IsInsideScreen(int2 PixelCoord, int2 Dimension)\n"
"{\n"
"    return PixelCoord.x >= 0 &&\n"
"           PixelCoord.y >= 0 &&\n"
"           PixelCoord.x < Dimension.x &&\n"
"           PixelCoord.y < Dimension.y;\n"
"}\n"
"\n"
"#endif // _SSR_COMMON_FXH_\n"
