"// This file is derived from the open source project provided by Intel Corportaion that\n"
"// requires the following notice to be kept:\n"
"//--------------------------------------------------------------------------------------\n"
"// Copyright 2013 Intel Corporation\n"
"// All Rights Reserved\n"
"//\n"
"// Permission is granted to use, copy, distribute and prepare derivative works of this\n"
"// software for any purpose and without fee, provided, that the above copyright notice\n"
"// and this statement appear in all copies.  Intel makes no representations about the\n"
"// suitability of this software for any purpose.  THIS SOFTWARE IS PROVIDED \"AS IS.\"\n"
"// INTEL SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, AND ALL LIABILITY,\n"
"// INCLUDING CONSEQUENTIAL AND OTHER INDIRECT DAMAGES, FOR THE USE OF THIS SOFTWARE,\n"
"// INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PROPRIETARY RIGHTS, AND INCLUDING THE\n"
"// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  Intel does not\n"
"// assume any responsibility for any errors which may appear in this software nor any\n"
"// responsibility to update it.\n"
"//--------------------------------------------------------------------------------------\n"
"\n"
"#ifndef _STRCUTURES_FXH_\n"
"#define _STRCUTURES_FXH_\n"
"\n"
"#define PI 3.1415928f\n"
"\n"
"#ifdef __cplusplus\n"
"\n"
"#ifndef BOOL\n"
"#   define BOOL int32_t // Do not use bool, because sizeof(bool)==1 !\n"
"#endif\n"
"\n"
"#ifndef TRUE\n"
"#   define TRUE 1\n"
"#endif\n"
"\n"
"#ifndef FALSE\n"
"#   define FALSE 0\n"
"#endif\n"
"\n"
"#else\n"
"\n"
"#   define BOOL bool\n"
"\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"#   define CHECK_STRUCT_ALIGNMENT(s) static_assert( sizeof(s) % 16 == 0, \"structure size is not multiple of 16\" );\n"
"#else\n"
"#   define CHECK_STRUCT_ALIGNMENT(s)\n"
"#endif\n"
"\n"
"#define MAX_CASCADES 8\n"
"struct CascadeAttribs\n"
"{\n"
"	float4 f4LightSpaceScale;\n"
"	float4 f4LightSpaceScaledBias;\n"
"    float4 f4StartEndZ;\n"
"};\n"
"#ifdef __cplusplus\n"
"static_assert( (sizeof(CascadeAttribs) % 16) == 0, \"sizeof(CascadeAttribs) is not multiple of 16\" );\n"
"#endif\n"
"\n"
"struct ShadowMapAttribs\n"
"{\n"
"    // 0\n"
"#ifdef __cplusplus\n"
"    float4x4 mWorldToLightViewT; // Matrices in HLSL are COLUMN-major while float4x4 is ROW major\n"
"#else\n"
"    matrix mWorldToLightView;  // Transform from view space to light projection space\n"
"#endif\n"
"    // 16\n"
"    CascadeAttribs Cascades[MAX_CASCADES];\n"
"\n"
"#ifdef __cplusplus\n"
"    float fCascadeCamSpaceZEnd[MAX_CASCADES];\n"
"    float4x4 mWorldToShadowMapUVDepthT[MAX_CASCADES];\n"
"#else\n"
"	float4 f4CascadeCamSpaceZEnd[MAX_CASCADES/4];\n"
"    matrix mWorldToShadowMapUVDepth[MAX_CASCADES];\n"
"#endif\n"
"\n"
"    // Do not use bool, because sizeof(bool)==1 !\n"
"	BOOL bVisualizeCascades;\n"
"\n"
"    // float3 f3Padding;\n"
"    // Stupid OpenGL compiler does not handle 3-component vectors properly\n"
"    // and screws up the structure layout.\n"
"    // Opengl.org suggests not using vec3 at all\n"
"    int Padding0, Padding1, Padding2;\n"
"};\n"
"#ifdef __cplusplus\n"
"static_assert( (sizeof(ShadowMapAttribs) % 16) == 0, \"sizeof(ShadowMapAttribs) is not multiple of 16\" );\n"
"#endif\n"
"\n"
"\n"
"struct LightAttribs\n"
"{\n"
"    float4 f4DirOnLight;\n"
"    float4 f4AmbientLight;\n"
"    float4 f4LightScreenPos;\n"
"    float4 f4ExtraterrestrialSunColor;\n"
"\n"
"    BOOL bIsLightOnScreen;\n"
"    // Stupid OpenGL compiler does not handle 3-component vectors properly\n"
"    // and screws up the structure layout.\n"
"    // Opengl.org suggests not using vec3 at all\n"
"    int Padding0, Padding1, Padding2;\n"
"\n"
"    ShadowMapAttribs ShadowAttribs;\n"
"};\n"
"CHECK_STRUCT_ALIGNMENT(LightAttribs)\n"
"\n"
"struct CameraAttribs\n"
"{\n"
"    float4 f4CameraPos;            ///< Camera world position\n"
"    float fNearPlaneZ; \n"
"    float fFarPlaneZ; // fNearPlaneZ < fFarPlaneZ\n"
"    float2 f2Dummy;\n"
"\n"
"#ifdef __cplusplus\n"
"    float4x4 mViewProjT;\n"
"    //float4x4 mViewT;\n"
"    float4x4 mProjT;\n"
"    float4x4 mViewProjInvT;\n"
"#else\n"
"    matrix mViewProj;\n"
"    //matrix mView;\n"
"    matrix mProj;\n"
"    matrix mViewProjInv;\n"
"#endif\n"
"};\n"
"CHECK_STRUCT_ALIGNMENT(CameraAttribs)\n"
"\n"
"#define LIGHT_SCTR_TECHNIQUE_EPIPOLAR_SAMPLING 0\n"
"#define LIGHT_SCTR_TECHNIQUE_BRUTE_FORCE 1\n"
"\n"
"#define CASCADE_PROCESSING_MODE_SINGLE_PASS 0\n"
"#define CASCADE_PROCESSING_MODE_MULTI_PASS 1\n"
"#define CASCADE_PROCESSING_MODE_MULTI_PASS_INST 2\n"
"\n"
"#define REFINEMENT_CRITERION_DEPTH_DIFF 0\n"
"#define REFINEMENT_CRITERION_INSCTR_DIFF 1\n"
"\n"
"// Extinction evaluation mode used when attenuating background\n"
"#define EXTINCTION_EVAL_MODE_PER_PIXEL 0// Evaluate extinction for each pixel using analytic formula \n"
"                                        // by Eric Bruneton\n"
"#define EXTINCTION_EVAL_MODE_EPIPOLAR 1 // Render extinction in epipolar space and perform\n"
"                                        // bilateral filtering in the same manner as for\n"
"                                        // inscattering\n"
"\n"
"#define SINGLE_SCTR_MODE_NONE 0\n"
"#define SINGLE_SCTR_MODE_INTEGRATION 1\n"
"#define SINGLE_SCTR_MODE_LUT 2\n"
"\n"
"#define MULTIPLE_SCTR_MODE_NONE 0\n"
"#define MULTIPLE_SCTR_MODE_UNOCCLUDED 1\n"
"#define MULTIPLE_SCTR_MODE_OCCLUDED 2\n"
"\n"
"#define TONE_MAPPING_MODE_EXP 0\n"
"#define TONE_MAPPING_MODE_REINHARD 1\n"
"#define TONE_MAPPING_MODE_REINHARD_MOD 2\n"
"#define TONE_MAPPING_MODE_UNCHARTED2 3\n"
"#define TONE_MAPPING_FILMIC_ALU 4\n"
"#define TONE_MAPPING_LOGARITHMIC 5\n"
"#define TONE_MAPPING_ADAPTIVE_LOG 6\n"
"\n"
"\n"
"struct PostProcessingAttribs\n"
"{\n"
"    uint m_uiNumEpipolarSlices;\n"
"    uint m_uiMaxSamplesInSlice;\n"
"    uint m_uiInitialSampleStepInSlice;\n"
"    uint m_uiEpipoleSamplingDensityFactor;\n"
"\n"
"    float m_fRefinementThreshold;\n"
"    // do not use bool, because sizeof(bool)==1 and as a result bool variables\n"
"    // will be incorrectly mapped on GPU constant buffer\n"
"    BOOL m_bShowSampling; \n"
"    BOOL m_bCorrectScatteringAtDepthBreaks; \n"
"    BOOL m_bShowDepthBreaks; \n"
"\n"
"    BOOL m_bShowLightingOnly;\n"
"    BOOL m_bOptimizeSampleLocations;\n"
"    BOOL m_bEnableLightShafts;\n"
"    uint m_uiInstrIntegralSteps;\n"
"    \n"
"    float2 m_f2ShadowMapTexelSize;\n"
"    uint m_uiShadowMapResolution;\n"
"    uint m_uiMinMaxShadowMapResolution;\n"
"\n"
"    BOOL m_bUse1DMinMaxTree;\n"
"    float m_fMaxShadowMapStep;\n"
"    float m_fMiddleGray;\n"
"    uint m_uiLightSctrTechnique;\n"
"\n"
"    int m_iNumCascades;\n"
"    int m_iFirstCascade;\n"
"    float m_fNumCascades;\n"
"    float m_fFirstCascade;\n"
"\n"
"    uint m_uiCascadeProcessingMode;\n"
"    uint m_uiRefinementCriterion;\n"
"    BOOL m_bIs32BitMinMaxMipMap;\n"
"    uint m_uiMultipleScatteringMode;\n"
"\n"
"    uint m_uiSingleScatteringMode;\n"
"    BOOL m_bAutoExposure;\n"
"    uint m_uiToneMappingMode;\n"
"    BOOL m_bLightAdaptation;\n"
"    \n"
"    float m_fWhitePoint;\n"
"    float m_fLuminanceSaturation;\n"
"    float2 f2Dummy;\n"
"    \n"
"    uint m_uiExtinctionEvalMode;\n"
"    BOOL m_bUseCustomSctrCoeffs;\n"
"    float m_fAerosolDensityScale;\n"
"    float m_fAerosolAbsorbtionScale;\n"
"\n"
"    float4 m_f4CustomRlghBeta;\n"
"    float4 m_f4CustomMieBeta;\n"
"\n"
"#ifdef __cplusplus\n"
"    PostProcessingAttribs() : \n"
"        m_uiNumEpipolarSlices(512),\n"
"        m_uiMaxSamplesInSlice(256),\n"
"        m_uiInitialSampleStepInSlice(16),\n"
"        // Note that sampling near the epipole is very cheap since only a few steps\n"
"        // required to perform ray marching\n"
"        m_uiEpipoleSamplingDensityFactor(2),\n"
"        m_fRefinementThreshold(0.03f),\n"
"        m_bShowSampling(FALSE),\n"
"        m_bCorrectScatteringAtDepthBreaks(FALSE),\n"
"        m_bShowDepthBreaks(FALSE),\n"
"        m_bShowLightingOnly(FALSE),\n"
"        m_bOptimizeSampleLocations(TRUE),\n"
"        m_bEnableLightShafts(TRUE),\n"
"        m_uiInstrIntegralSteps(30),\n"
"        m_f2ShadowMapTexelSize(0,0),\n"
"        m_uiMinMaxShadowMapResolution(0),\n"
"        m_bUse1DMinMaxTree(TRUE),\n"
"        m_fMaxShadowMapStep(16.f),\n"
"        m_fMiddleGray(0.18f),\n"
"        m_uiLightSctrTechnique(LIGHT_SCTR_TECHNIQUE_EPIPOLAR_SAMPLING),\n"
"        m_iNumCascades(0),\n"
"        m_iFirstCascade(2),\n"
"        m_fNumCascades(0),\n"
"        m_fFirstCascade(1),\n"
"        m_uiCascadeProcessingMode(CASCADE_PROCESSING_MODE_SINGLE_PASS),\n"
"        m_uiRefinementCriterion(REFINEMENT_CRITERION_INSCTR_DIFF),\n"
"        m_bIs32BitMinMaxMipMap(FALSE),\n"
"        m_uiMultipleScatteringMode(MULTIPLE_SCTR_MODE_UNOCCLUDED),\n"
"        m_uiSingleScatteringMode(SINGLE_SCTR_MODE_INTEGRATION),\n"
"        m_bAutoExposure(TRUE),\n"
"        m_uiToneMappingMode(TONE_MAPPING_MODE_UNCHARTED2),\n"
"        m_bLightAdaptation(TRUE),\n"
"        m_fWhitePoint(3.f),\n"
"        m_fLuminanceSaturation(1.f),\n"
"        m_uiExtinctionEvalMode(EXTINCTION_EVAL_MODE_EPIPOLAR),\n"
"        m_bUseCustomSctrCoeffs(FALSE),\n"
"        m_fAerosolDensityScale(1.f),\n"
"        m_fAerosolAbsorbtionScale(0.1f),\n"
"        m_f4CustomRlghBeta( 5.8e-6f, 13.5e-6f, 33.1e-6f, 0.f ),\n"
"        m_f4CustomMieBeta(2.e-5f, 2.e-5f, 2.e-5f, 0.f)\n"
"    {}\n"
"#endif\n"
"};\n"
"CHECK_STRUCT_ALIGNMENT(PostProcessingAttribs)\n"
"\n"
"struct AirScatteringAttribs\n"
"{\n"
"    // Angular Rayleigh scattering coefficient contains all the terms exepting 1 + cos^2(Theta):\n"
"    // Pi^2 * (n^2-1)^2 / (2*N) * (6+3*Pn)/(6-7*Pn)\n"
"    float4 f4AngularRayleighSctrCoeff;\n"
"    // Total Rayleigh scattering coefficient is the integral of angular scattering coefficient in all directions\n"
"    // and is the following:\n"
"    // 8 * Pi^3 * (n^2-1)^2 / (3*N) * (6+3*Pn)/(6-7*Pn)\n"
"    float4 f4TotalRayleighSctrCoeff;\n"
"    float4 f4RayleighExtinctionCoeff;\n"
"\n"
"    // Note that angular scattering coefficient is essentially a phase function multiplied by the\n"
"    // total scattering coefficient\n"
"    float4 f4AngularMieSctrCoeff;\n"
"    float4 f4TotalMieSctrCoeff;\n"
"    float4 f4MieExtinctionCoeff;\n"
"\n"
"    float4 f4TotalExtinctionCoeff;\n"
"    // Cornette-Shanks phase function (see Nishita et al. 93) normalized to unity has the following form:\n"
"    // F(theta) = 1/(4*PI) * 3*(1-g^2) / (2*(2+g^2)) * (1+cos^2(theta)) / (1 + g^2 - 2g*cos(theta))^(3/2)\n"
"    float4 f4CS_g; // x == 3*(1-g^2) / (2*(2+g^2))\n"
"                   // y == 1 + g^2\n"
"                   // z == -2*g\n"
"\n"
"    float fEarthRadius;\n"
"    float fAtmTopHeight;\n"
"    float2 f2ParticleScaleHeight;\n"
"    \n"
"    float fTurbidity;\n"
"    float fAtmTopRadius;\n"
"    float m_fAerosolPhaseFuncG;\n"
"    float m_fDummy;\n"
"\n"
"\n"
"#ifdef __cplusplus\n"
"    AirScatteringAttribs():\n"
"        // Air molecules and aerosols are assumed to be distributed\n"
"        // between 6360 km and 6420 km\n"
"        fEarthRadius(6360000.f),\n"
"        fAtmTopHeight(80000.f),\n"
"        f2ParticleScaleHeight(7994.f, 1200.f),\n"
"        fTurbidity(1.02f),\n"
"        m_fAerosolPhaseFuncG(0.76f)\n"
"    {\n"
"        fAtmTopRadius = fEarthRadius + fAtmTopHeight;\n"
"    }\n"
"#endif\n"
"};\n"
"\n"
"CHECK_STRUCT_ALIGNMENT(AirScatteringAttribs)\n"
"\n"
"struct MiscDynamicParams\n"
"{\n"
"    float fMaxStepsAlongRay;   // Maximum number of steps during ray tracing\n"
"    float fCascadeInd;\n"
"    float fElapsedTime;\n"
"    float fDummy;\n"
"\n"
"#ifdef __cplusplus\n"
"    uint ui4SrcMinMaxLevelXOffset;\n"
"    uint ui4SrcMinMaxLevelYOffset;\n"
"    uint ui4DstMinMaxLevelXOffset;\n"
"    uint ui4DstMinMaxLevelYOffset;\n"
"#else\n"
"    uint4 ui4SrcDstMinMaxLevelOffset;\n"
"#endif\n"
"};\n"
"CHECK_STRUCT_ALIGNMENT(MiscDynamicParams)\n"
"\n"
"#endif //_STRCUTURES_FXH_\n"
