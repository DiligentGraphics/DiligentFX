"#ifndef _GLTF_PBR_SHADING_FXH_\n"
"#define _GLTF_PBR_SHADING_FXH_\n"
"\n"
"#include \"PBR_Common.fxh\"\n"
"#include \"ShaderUtilities.fxh\"\n"
"\n"
"#ifndef GLTF_PBR_MANUAL_SRGB\n"
"#   define  GLTF_PBR_MANUAL_SRGB    1\n"
"#endif\n"
"\n"
"#ifndef SRGB_FAST_APPROXIMATION\n"
"#   define  SRGB_FAST_APPROXIMATION 1\n"
"#endif\n"
"\n"
"#define GLTF_PBR_USE_ENV_MAP_LOD\n"
"#define GLTF_PBR_USE_HDR_CUBEMAPS\n"
"\n"
"float GetPerceivedBrightness(FLOAT3 rgb)\n"
"{\n"
"    return sqrt(FLOAT(0.299) * rgb.r * rgb.r + FLOAT(0.587) * rgb.g * rgb.g + FLOAT(0.114) * rgb.b * rgb.b);\n"
"}\n"
"\n"
"// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34\n"
"FLOAT GLTF_PBR_SolveMetallic(FLOAT3 diffuse,\n"
"                             FLOAT3 specular,\n"
"                             FLOAT  oneMinusSpecularStrength)\n"
"{\n"
"    const FLOAT c_MinReflectance = 0.04;\n"
"    FLOAT specularBrightness = GetPerceivedBrightness(specular);\n"
"    if (specularBrightness < c_MinReflectance)\n"
"    {\n"
"        return _0f;\n"
"    }\n"
"\n"
"    FLOAT diffuseBrightness = GetPerceivedBrightness(diffuse);\n"
"\n"
"    FLOAT a = c_MinReflectance;\n"
"    FLOAT b = diffuseBrightness * oneMinusSpecularStrength / (_1f - c_MinReflectance) + specularBrightness - _2f * c_MinReflectance;\n"
"    FLOAT c = c_MinReflectance - specularBrightness;\n"
"    FLOAT D = b * b - FLOAT(4.0) * a * c;\n"
"\n"
"    return clamp((-b + sqrt(D)) / (_2f * a), _0f, _1f);\n"
"}\n"
"\n"
"\n"
"FLOAT3 SRGBtoLINEAR(FLOAT3 srgbIn)\n"
"{\n"
"#ifdef GLTF_PBR_MANUAL_SRGB\n"
"#   ifdef SRGB_FAST_APPROXIMATION\n"
"        FLOAT3 linOut = pow(saturate(srgbIn.xyz), FLOAT3(2.2, 2.2, 2.2));\n"
"#   else\n"
"        FLOAT3 bLess  = step(FLOAT3(0.04045, 0.04045, 0.04045), srgbIn.xyz);\n"
"        FLOAT3 linOut = mix( srgbIn.xyz / FLOAT(12.92), pow(saturate((srgbIn.xyz + FLOAT3(0.055, 0.055, 0.055)) / FLOAT(1.055)), FLOAT3(2.4, 2.4, 2.4)), bLess );\n"
"#   endif\n"
"        return linOut;\n"
"#else\n"
"    return srgbIn;\n"
"#endif\n"
"}\n"
"\n"
"FLOAT4 SRGBtoLINEAR(FLOAT4 srgbIn)\n"
"{\n"
"    return FLOAT4(SRGBtoLINEAR(srgbIn.xyz), srgbIn.w);\n"
"}\n"
"\n"
"\n"
"FLOAT3 GLTF_PBR_ApplyDirectionalLight(FLOAT3 lightDir, FLOAT3 lightColor, SurfaceReflectanceInfo srfInfo, FLOAT3 normal, FLOAT3 view)\n"
"{\n"
"    FLOAT3 pointToLight = -lightDir;\n"
"    FLOAT3 diffuseContrib, specContrib;\n"
"    FLOAT  NdotL;\n"
"    SmithGGX_BRDF(pointToLight, normal, view, srfInfo, diffuseContrib, specContrib, NdotL);\n"
"    // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n"
"    FLOAT3 shade = (diffuseContrib + specContrib) * NdotL;\n"
"    return lightColor * shade;\n"
"}\n"
"\n"
"\n"
"// Find the normal for this fragment, pulling either from a predefined normal map\n"
"// or from the interpolated mesh normal and tangent attributes.\n"
"FLOAT3 GLTF_PBR_PerturbNormal(in FLOAT3 dPos_dx,\n"
"                              in FLOAT3 dPos_dy,\n"
"                              in FLOAT2 dUV_dx,\n"
"                              in FLOAT2 dUV_dy,\n"
"                              in FLOAT3 Normal,\n"
"                              in FLOAT3 TSNormal,\n"
"                              bool      HasUV,\n"
"                              bool      IsFrontFace)\n"
"{\n"
"    // Retrieve the tangent space matrix\n"
"    FLOAT NormalLen = length(Normal);\n"
"    FLOAT3 ng;\n"
"    if (NormalLen > 1e-5)\n"
"    {\n"
"        ng = Normal/NormalLen;\n"
"    }\n"
"    else\n"
"    {\n"
"        ng = normalize(cross(dPos_dx, dPos_dy));\n"
"#if (defined(GLSL) || defined(GL_ES)) && !defined(VULKAN)\n"
"        // In OpenGL screen is upside-down, so we have to invert the vector\n"
"        ng *= -_1f;\n"
"#endif\n"
"    }\n"
"\n"
"    if (HasUV)\n"
"    {\n"
"        return TransformTangentSpaceNormalGrad(dPos_dx, dPos_dy, dUV_dx, dUV_dy, ng, TSNormal * (IsFrontFace ? +_1f : -_1f));\n"
"    }\n"
"    else\n"
"    {\n"
"        return ng * (IsFrontFace ? +_1f : -_1f);\n"
"    }\n"
"}\n"
"\n"
"\n"
"struct GLTF_PBR_IBL_Contribution\n"
"{\n"
"    FLOAT3 f3Diffuse;\n"
"    FLOAT3 f3Specular;\n"
"};\n"
"\n"
"// Calculation of the lighting contribution from an optional Image Based Light source.\n"
"// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n"
"// See our README.md on Environment Maps [3] for additional discussion.\n"
"GLTF_PBR_IBL_Contribution GLTF_PBR_GetIBLContribution(\n"
"                        in SurfaceReflectanceInfo SrfInfo,\n"
"                        in FLOAT3                 n,\n"
"                        in FLOAT3                 v,\n"
"                        in FLOAT                  PrefilteredCubeMipLevels,\n"
"                        in Texture2D              BRDF_LUT,\n"
"                        in SamplerState           BRDF_LUT_sampler,\n"
"                        in TextureCube            IrradianceMap,\n"
"                        in SamplerState           IrradianceMap_sampler,\n"
"                        in TextureCube            PrefilteredEnvMap,\n"
"                        in SamplerState           PrefilteredEnvMap_sampler)\n"
"{\n"
"    FLOAT NdotV = clamp(dot(n, v), _0f, _1f);\n"
"\n"
"    FLOAT lod = clamp(SrfInfo.PerceptualRoughness * PrefilteredCubeMipLevels, _0f, PrefilteredCubeMipLevels);\n"
"    FLOAT3 reflection = normalize(reflect(-v, n));\n"
"\n"
"    FLOAT2 brdfSamplePoint = clamp(FLOAT2(NdotV, SrfInfo.PerceptualRoughness), FLOAT2(0.0, 0.0), FLOAT2(1.0, 1.0));\n"
"    // retrieve a scale and bias to F0. See [1], Figure 3\n"
"    FLOAT2 brdf = BRDF_LUT.Sample(BRDF_LUT_sampler, brdfSamplePoint).rg;\n"
"\n"
"    FLOAT4 diffuseSample = IrradianceMap.Sample(IrradianceMap_sampler, n);\n"
"\n"
"#ifdef GLTF_PBR_USE_ENV_MAP_LOD\n"
"    FLOAT4 specularSample = PrefilteredEnvMap.SampleLevel(PrefilteredEnvMap_sampler, reflection, lod);\n"
"#else\n"
"    FLOAT4 specularSample = PrefilteredEnvMap.Sample(PrefilteredEnvMap_sampler, reflection);\n"
"#endif\n"
"\n"
"#ifdef GLTF_PBR_USE_HDR_CUBEMAPS\n"
"    // Already linear.\n"
"    FLOAT3 diffuseLight  = diffuseSample.rgb;\n"
"    FLOAT3 specularLight = specularSample.rgb;\n"
"#else\n"
"    FLOAT3 diffuseLight  = SRGBtoLINEAR(diffuseSample).rgb;\n"
"    FLOAT3 specularLight = SRGBtoLINEAR(specularSample).rgb;\n"
"#endif\n"
"\n"
"    GLTF_PBR_IBL_Contribution IBLContrib;\n"
"    IBLContrib.f3Diffuse  = diffuseLight * SrfInfo.DiffuseColor;\n"
"    IBLContrib.f3Specular = specularLight * (SrfInfo.Reflectance0 * brdf.x + SrfInfo.Reflectance90 * brdf.y);\n"
"    return IBLContrib;\n"
"}\n"
"\n"
"/// Calculates surface reflectance info\n"
"\n"
"/// \\param [in]  Workflow     - PBR workflow (PBR_WORKFLOW_SPECULAR_GLOSINESS or PBR_WORKFLOW_METALLIC_ROUGHNESS).\n"
"/// \\param [in]  BaseColor    - Material base color.\n"
"/// \\param [in]  PhysicalDesc - Physical material description. For Metallic-roughness workflow,\n"
"///                             \'g\' channel stores roughness, \'b\' channel stores metallic.\n"
"/// \\param [out] Metallic     - Metallic value used for shading.\n"
"SurfaceReflectanceInfo GLTF_PBR_GetSurfaceReflectance(int       Workflow,\n"
"                                                      FLOAT4    BaseColor,\n"
"                                                      FLOAT4    PhysicalDesc,\n"
"                                                      out FLOAT Metallic)\n"
"{\n"
"    SurfaceReflectanceInfo SrfInfo;\n"
"\n"
"    FLOAT3 SpecularColor;\n"
"\n"
"    FLOAT3 f0 = FLOAT3(0.04, 0.04, 0.04);\n"
"\n"
"    // Metallic and Roughness material properties are packed together\n"
"    // In glTF, these factors can be specified by fixed scalar values\n"
"    // or from a metallic-roughness map\n"
"    if (Workflow == PBR_WORKFLOW_SPECULAR_GLOSINESS)\n"
"    {\n"
"        SrfInfo.PerceptualRoughness = _1f - PhysicalDesc.a; // glossiness to roughness\n"
"        f0 = PhysicalDesc.rgb;\n"
"\n"
"        // f0 = specular\n"
"        SpecularColor = f0;\n"
"        FLOAT oneMinusSpecularStrength = _1f - max(max(f0.r, f0.g), f0.b);\n"
"        SrfInfo.DiffuseColor = BaseColor.rgb * oneMinusSpecularStrength;\n"
"\n"
"        // do conversion between metallic M-R and S-G metallic\n"
"        Metallic = GLTF_PBR_SolveMetallic(BaseColor.rgb, SpecularColor, oneMinusSpecularStrength);\n"
"    }\n"
"    else if (Workflow == PBR_WORKFLOW_METALLIC_ROUGHNESS)\n"
"    {\n"
"        // Roughness is stored in the \'g\' channel, metallic is stored in the \'b\' channel.\n"
"        // This layout intentionally reserves the \'r\' channel for (optional) occlusion map data\n"
"        SrfInfo.PerceptualRoughness = PhysicalDesc.g;\n"
"        Metallic                    = PhysicalDesc.b;\n"
"\n"
"        SrfInfo.DiffuseColor  = BaseColor.rgb * (FLOAT3(1.0, 1.0, 1.0) - f0) * (_1f - Metallic);\n"
"        SpecularColor         = lerp(f0, BaseColor.rgb, Metallic);\n"
"    }\n"
"\n"
"//#ifdef ALPHAMODE_OPAQUE\n"
"//    baseColor.a = 1.0;\n"
"//#endif\n"
"//\n"
"//#ifdef MATERIAL_UNLIT\n"
"//    gl_FragColor = FLOAT4(gammaCorrection(baseColor.rgb), baseColor.a);\n"
"//    return;\n"
"//#endif\n"
"\n"
"    SrfInfo.PerceptualRoughness = clamp(SrfInfo.PerceptualRoughness, _0f, _1f);\n"
"\n"
"    // Compute reflectance.\n"
"    FLOAT3 Reflectance0  = SpecularColor;\n"
"    FLOAT  MaxR0         = max(max(Reflectance0.r, Reflectance0.g), Reflectance0.b);\n"
"    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n"
"    FLOAT R90 = clamp(MaxR0 * FLOAT(50.0), _0f, _1f);\n"
"\n"
"    SrfInfo.Reflectance0  = Reflectance0;\n"
"    SrfInfo.Reflectance90 = FLOAT3(R90, R90, R90);\n"
"\n"
"    return SrfInfo;\n"
"}\n"
"\n"
"/// Calculates surface reflectance info for Metallic-roughness workflow\n"
"SurfaceReflectanceInfo GLTF_PBR_GetSurfaceReflectanceMR(FLOAT3 BaseColor,\n"
"                                                        FLOAT  Metallic,\n"
"                                                        FLOAT  Roughness)\n"
"{\n"
"    SurfaceReflectanceInfo SrfInfo;\n"
"\n"
"    FLOAT f0 = 0.04;\n"
"\n"
"    SrfInfo.PerceptualRoughness = Roughness;\n"
"    SrfInfo.DiffuseColor        = BaseColor * ((_1f - f0) * (_1f - Metallic));\n"
"\n"
"    FLOAT3 Reflectance0 = lerp(FLOAT3(f0, f0, f0), BaseColor, Metallic);\n"
"    FLOAT  MaxR0        = max(max(Reflectance0.r, Reflectance0.g), Reflectance0.b);\n"
"    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to \"Real-Time-Rendering\" 4th editon on page 325.\n"
"    FLOAT R90 = min(MaxR0 * FLOAT(50.0), _1f);\n"
"\n"
"    SrfInfo.Reflectance0  = Reflectance0;\n"
"    SrfInfo.Reflectance90 = FLOAT3(R90, R90, R90);\n"
"\n"
"    return SrfInfo;\n"
"}\n"
"\n"
"#endif // _GLTF_PBR_SHADING_FXH_\n"
