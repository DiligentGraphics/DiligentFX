"#ifndef _POST_FX_COMMON_FXH_\n"
"#define _POST_FX_COMMON_FXH_\n"
"\n"
"#define M_PI                      3.14159265358979\n"
"#define M_EPSILON                 1e-3\n"
"#define M_GOLDEN_RATIO            1.61803398875\n"
"\n"
"#define FLT_EPS                   5.960464478e-8\n"
"#define FLT_MAX                   3.402823466e+38\n"
"#define FLT_MIN                   1.175494351e-38\n"
"\n"
"struct CRNG\n"
"{\n"
"    uint Seed;\n"
"};\n"
"\n"
"uint PCGHash(uint Seed)\n"
"{\n"
"    uint State = Seed * 747796405u + 2891336453u;\n"
"    uint Word = ((State >> ((State >> 28u) + 4u)) ^ State) * 277803737u;\n"
"    return (Word >> 22u) ^ Word;\n"
"}\n"
"\n"
"CRNG InitCRND(uint2 id, uint FrameIndex)\n"
"{\n"
"    CRNG Rng;\n"
"    Rng.Seed = FrameIndex + PCGHash((id.x << 16u) | id.y);\n"
"    return Rng;\n"
"}\n"
"\n"
"float Rand(inout CRNG Rng)\n"
"{\n"
"    Rng.Seed = PCGHash(Rng.Seed);\n"
"    return asfloat(0x3f800000u | (Rng.Seed >> 9u)) - 1.0;\n"
"}\n"
"\n"
"float Luminance(float3 Color)\n"
"{\n"
"    return dot(Color, float3(0.299f, 0.587f, 0.114f));\n"
"}\n"
"\n"
"float3 ProjectPosition(float3 Origin, float4x4 Transform)\n"
"{\n"
"    float4 Projected = mul(float4(Origin, 1.0), Transform);\n"
"    Projected.xyz /= Projected.w;\n"
"    Projected.xy = NormalizedDeviceXYToTexUV(Projected.xy);\n"
"    return Projected.xyz;\n"
"}\n"
"\n"
"float3 ProjectDirection(float3 Origin, float3 Direction, float3 OriginSS, float4x4 Mat)\n"
"{\n"
"    return ProjectPosition(Origin + Direction, Mat) - OriginSS;\n"
"}\n"
"\n"
"float3 InvProjectPosition(float3 Coord, float4x4 Transform)\n"
"{\n"
"    Coord.xy = TexUVToNormalizedDeviceXY(Coord.xy);\n"
"    float4 Projected = mul(float4(Coord, 1.0), Transform);\n"
"    return Projected.xyz /= Projected.w;\n"
"}\n"
"\n"
"float DepthToCameraZ(in float fDepth, in float4x4 mProj)\n"
"{\n"
"    // Transformations to/from normalized device coordinates are the\n"
"    // same in both APIs.\n"
"    // However, in GL, depth must be transformed to NDC Z first\n"
"\n"
"    float z = DepthToNormalizedDeviceZ(fDepth);\n"
"    return MATRIX_ELEMENT(mProj, 3, 2) / (z - MATRIX_ELEMENT(mProj, 2, 2));\n"
"}\n"
"\n"
"float CameraZToDepth(in float fDepth, in float4x4 mProj)\n"
"{\n"
"    // Transformations to/from normalized device coordinates are the\n"
"    // same in both APIs.\n"
"    // However, in GL, depth must be transformed to NDC Z first\n"
"\n"
"    float z = MATRIX_ELEMENT(mProj, 3, 2) / fDepth + MATRIX_ELEMENT(mProj, 2, 2);\n"
"    return NormalizedDeviceZToDepth(z);\n"
"}\n"
"\n"
"bool IsInsideScreen(int2 PixelCoord, int2 Dimension)\n"
"{\n"
"    return PixelCoord.x >= 0 &&\n"
"           PixelCoord.y >= 0 &&\n"
"           PixelCoord.x < Dimension.x &&\n"
"           PixelCoord.y < Dimension.y;\n"
"}\n"
"\n"
"bool IsInsideScreen(float2 PixelCoord, float2 Dimension)\n"
"{\n"
"    return PixelCoord.x >= 0.0 &&\n"
"           PixelCoord.y >= 0.0 &&\n"
"           PixelCoord.x < Dimension.x &&\n"
"           PixelCoord.y < Dimension.y;\n"
"}\n"
"\n"
"#endif // _SSAO_COMMON_FXH_\n"
