"#include \"ScreenSpaceReflectionStructures.fxh\"\n"
"#include \"PBR_Common.fxh\"\n"
"#include \"SSR_Common.fxh\"\n"
"\n"
"cbuffer cbScreenSpaceReflectionAttribs\n"
"{\n"
"    ScreenSpaceReflectionAttribs g_SSRAttribs;\n"
"}\n"
"\n"
"struct PSOutput\n"
"{\n"
"    float4 ResolvedRadiance : SV_Target0;\n"
"    float  ResolvedVariance : SV_Target1;\n"
"    float  ResolvedDepth    : SV_Target2;\n"
"};\n"
"\n"
"Texture2D<float>  g_TextureRoughness;\n"
"Texture2D<float3> g_TextureNormal;\n"
"Texture2D<float>  g_TextureDepth;\n"
"Texture2D<float4> g_TextureRayDirectionPDF;\n"
"Texture2D<float4> g_TextureIntersectSpecular;\n"
"\n"
"struct PixelAreaStatistic\n"
"{\n"
"    float Mean;\n"
"    float Variance;\n"
"    float WeightSum;\n"
"    float4 ColorSum;\n"
"};\n"
"\n"
"float SampleRoughness(int2 PixelCoord)\n"
"{\n"
"    return g_TextureRoughness.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float3 SampleNormalWS(int2 PixelCoord)\n"
"{\n"
"    return g_TextureNormal.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SampleDepth(int2 PixelCoord)\n"
"{\n"
"    return g_TextureDepth.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float2 ComputeWeightRayLength(int2 PixelCoord, float3 V, float3 N, float Roughness, float NdotV)\n"
"{\n"
"    float4 RayDirectionPDF = g_TextureRayDirectionPDF.Load(int3(PixelCoord, 0));\n"
"    float InvRayLength = rsqrt(dot(RayDirectionPDF.xyz, RayDirectionPDF.xyz));\n"
"    if (isnan(InvRayLength))\n"
"        return float2(1.0e-6f, 1.0e-6f);\n"
"\n"
"    float3 RayDirection = RayDirectionPDF.xyz * InvRayLength;\n"
"    float PDF = RayDirectionPDF.w;\n"
"\n"
"    float3 L = RayDirection;\n"
"    float3 H = normalize(L + V);\n"
"\n"
"    float NdotH = saturate(dot(N, H));\n"
"    float NdotL = saturate(dot(N, L));\n"
"\n"
"    float Vis = SmithGGXVisibilityCorrelated(NdotL, NdotV, Roughness);\n"
"    float D = NormalDistribution_GGX(NdotH, Roughness);\n"
"    float LocalBRDF = Vis * D * NdotL;\n"
"    return float2(max(LocalBRDF / max(PDF, 1.0e-5f), 1e-6), rcp(InvRayLength));\n"
"}\n"
"\n"
"// Weighted incremental variance\n"
"// https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n"
"void ComputeWeightedVariance(inout PixelAreaStatistic Stat, float4 SampleColor, float Weight)\n"
"{\n"
"    Stat.ColorSum += Weight * SampleColor;\n"
"    Stat.WeightSum += Weight;\n"
"\n"
"    float Value = Luminance(SampleColor.rgb);\n"
"    float PrevMean = Stat.Mean;\n"
"\n"
"    Stat.Mean += Weight * rcp(Stat.WeightSum) * (Value - PrevMean);\n"
"    Stat.Variance += Weight * (Value - PrevMean) * (Value - Stat.Mean);\n"
"}\n"
"\n"
"float ComputeResolvedDepth(float3 PositionWS, float SurfaceHitDistance)\n"
"{\n"
"    float CameraSurfaceDistance = distance(g_SSRAttribs.CameraPosition.xyz, PositionWS);\n"
"    return CameraZToDepth(CameraSurfaceDistance + SurfaceHitDistance, g_SSRAttribs.ProjMatrix);\n"
"}\n"
"\n"
"float3 ScreenSpaceToWorldSpace(float3 ScreenCoordUV)\n"
"{\n"
"    return InvProjectPosition(ScreenCoordUV, g_SSRAttribs.InvViewProjMatrix);\n"
"}\n"
"\n"
"SSR_ATTRIBUTE_EARLY_DEPTH_STENCIL\n"
"PSOutput ComputeSpatialReconstructionPS(in float4 Position : SV_Position)\n"
"{\n"
"    CRNG Rng = InitCRND(uint2(Position.xy), 0u);\n"
"\n"
"    float2 ScreenCoordUV = Position.xy * g_SSRAttribs.InverseRenderSize;\n"
"    float3 PositionWS = ScreenSpaceToWorldSpace(float3(ScreenCoordUV, SampleDepth(int2(Position.xy))));\n"
"    float3 NormalWS = SampleNormalWS(int2(Position.xy));\n"
"    float3 ViewWS = normalize(g_SSRAttribs.CameraPosition.xyz - PositionWS);\n"
"    float NdotV = saturate(dot(NormalWS, ViewWS));\n"
"\n"
"    float Roughness = SampleRoughness(int2(Position.xy));\n"
"    float RoughnessFactor = saturate(float(SSR_SPATIAL_RECONSTRUCTION_ROUGHNESS_FACTOR) * sqrt(Roughness));\n"
"    float Radius = lerp(0.0, g_SSRAttribs.SpatialReconstructionRadius, RoughnessFactor);\n"
"    uint SampleCount = uint(lerp(1.0, float(SSR_SPATIAL_RECONSTRUCTION_SAMPLES), Radius / g_SSRAttribs.SpatialReconstructionRadius));\n"
"    float2 RandomOffset = float2(Rand(Rng), Rand(Rng));\n"
"\n"
"    PixelAreaStatistic PixelAreaStat;\n"
"    PixelAreaStat.ColorSum = float4(0.0, 0.0, 0.0, 0.0);\n"
"    PixelAreaStat.WeightSum = 0.0;\n"
"    PixelAreaStat.Variance = 0.0;\n"
"    PixelAreaStat.Mean = 0.0;\n"
"\n"
"    float NearestSurfaceHitDistance = 0.0;\n"
"\n"
"    // TODO: Try to implement sampling from https://youtu.be/MyTOGHqyquU?t=1043\n"
"    for (uint SampleIdx = 0u; SampleIdx < SampleCount; SampleIdx++)\n"
"    {\n"
"        float2 Xi = 2.0 * frac(HammersleySequence(SampleIdx, SampleCount) + RandomOffset) - 1.0;\n"
"        int2 SampleCoord = int2(Position.xy + Radius * Xi);\n"
"        if (IsInsideScreen(SampleCoord, g_SSRAttribs.RenderSize))\n"
"        {\n"
"            float2 WeightLength = ComputeWeightRayLength(SampleCoord, ViewWS, NormalWS, Roughness, NdotV);\n"
"            float4 SampleColor = g_TextureIntersectSpecular.Load(int3(SampleCoord, 0));\n"
"            ComputeWeightedVariance(PixelAreaStat, SampleColor, WeightLength.x);\n"
"\n"
"            if (WeightLength.x > 1.0e-6)\n"
"                NearestSurfaceHitDistance = max(WeightLength.y, NearestSurfaceHitDistance);\n"
"        }\n"
"    }\n"
"\n"
"    PSOutput Output;\n"
"    Output.ResolvedRadiance = PixelAreaStat.ColorSum / max(PixelAreaStat.WeightSum, 1e-6f);\n"
"    Output.ResolvedVariance = PixelAreaStat.Variance / max(PixelAreaStat.WeightSum, 1e-6f);\n"
"    Output.ResolvedDepth = ComputeResolvedDepth(PositionWS, NearestSurfaceHitDistance);\n"
"    return Output;\n"
"}\n"
