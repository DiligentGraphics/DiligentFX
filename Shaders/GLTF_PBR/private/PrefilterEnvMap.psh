#include "GLTF_PBR_PrecomputeCommon.fxh"

TextureCube  g_EnvironmentMap;
SamplerState g_EnvironmentMap_sampler;

cbuffer FilterAttribs
{
    float4x4 g_Rotation;

    float    g_Roughness;
    float    g_EnvMapDim;
    uint     g_NumSamples;
    float    Dummy;
}

// Normal Distribution function
float D_GGX(float dotNH, float roughness)
{
	float alpha = roughness * roughness;
	float alpha2 = alpha * alpha;
	float denom = dotNH * dotNH * (alpha2 - 1.0) + 1.0;
	return alpha2 / (PI * denom*denom); 
}

void main(in float4  Pos      : SV_Position,
          in float3  WorldPos : WORLD_POS,
          out float4 Color    : SV_Target)
{		
	float3 N = normalize(WorldPos);
	float3 V = N;
	float3 color = float3(0.0, 0.0, 0.0);
	float totalWeight = 0.0;
	for (uint i = 0u; i < g_NumSamples; i++)
    {
		float2 Xi = hammersley2d(i, g_NumSamples);
		float3 H = importanceSample_GGX(Xi, g_Roughness, N);
		float3 L = 2.0 * dot(V, H) * H - V;
		float dotNL = clamp(dot(N, L), 0.0, 1.0);
		if (dotNL > 0.0)
        {
			// Filtering based on https://placeholderart.wordpress.com/2015/07/28/implementation-notes-runtime-environment-map-filtering-for-image-based-lighting/

			float dotNH = clamp(dot(N, H), 0.0, 1.0);
			float dotVH = clamp(dot(V, H), 0.0, 1.0);

			// Probability Distribution Function
			float pdf = D_GGX(dotNH, g_Roughness) * dotNH / (4.0 * dotVH) + 0.0001;
			// Slid angle of current smple
			float omegaS = 1.0 / (float(g_NumSamples) * pdf);
			// Solid angle of 1 pixel across all cube faces
			float omegaP = 4.0 * PI / (6.0 * g_EnvMapDim * g_EnvMapDim);
			// Biased (+1.0) mip level for better result
			float mipLevel = (g_Roughness == 0.0) ? 0.0 : max(0.5 * log2(omegaS / omegaP) + 1.0, 0.0f);
			color += g_EnvironmentMap.SampleLevel(g_EnvironmentMap_sampler, L, mipLevel).rgb * dotNL;
			totalWeight += dotNL;

		}
	}
	Color =  float4((color / totalWeight), 1.0);
}
