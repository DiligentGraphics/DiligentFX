// PBR shader based on the Khronos WebGL PBR implementation
// See https://github.com/KhronosGroup/glTF-WebGL-PBR
// Supports both metallic roughness and specular glossiness inputs

#include "BasicStructures.fxh"
#include "GLTF_PBR_Structures.fxh"
#include "PBR_Common.fxh"
#include "ToneMapping.fxh"

#define  MANUAL_SRGB             1
#define  SRGB_FAST_APPROXIMATION 1

#ifndef ALLOW_DEBUG_VIEW
#   define ALLOW_DEBUG_VIEW 0
#endif

cbuffer cbCameraAttribs
{
    CameraAttribs g_CameraAttribs;
}

cbuffer cbLightAttribs
{
    LightAttribs g_LightAttribs;
}

cbuffer cbMaterialInfo
{
    GLTFMaterialInfo g_MaterialInfo;
}

cbuffer cbRenderParameters
{
    GLTFRenderParameters g_RenderParameters;
}


TextureCube  g_IrradianceMap;
SamplerState g_IrradianceMap_sampler;

TextureCube  g_PrefilteredMap;
SamplerState g_PrefilteredMap_sampler;

Texture2D     g_BRDF_LUT;
SamplerState  g_BRDF_LUT_sampler;


Texture2D    g_ColorMap;
SamplerState g_ColorMap_sampler;

Texture2D    g_PhysicalDescriptorMap;
SamplerState g_PhysicalDescriptorMap_sampler;

Texture2D    g_NormalMap;
SamplerState g_NormalMap_sampler;

Texture2D    g_AOMap;
SamplerState g_AOMap_sampler;

Texture2D    g_EmissiveMap;
SamplerState g_EmissiveMap_sampler;


struct AngularInfo
{
    float NdotL;   // cos angle between normal and light direction
    float NdotV;   // cos angle between normal and view direction
    float NdotH;   // cos angle between normal and half vector
    float LdotH;   // cos angle between light direction and half vector
    float VdotH;   // cos angle between view direction and half vector
};

AngularInfo GetAngularInfo(float3 pointToLight, float3 normal, float3 view)
{
    // Standard one-letter names
    float3 n = normalize(normal);           // Outward direction of surface point
    float3 v = normalize(view);             // Direction from surface point to camera
    float3 l = normalize(pointToLight);     // Direction from surface point to light
    float3 h = normalize(l + v);            // Direction of the vector between l and v

    AngularInfo info;
    info.NdotL = clamp(dot(n, l), 0.0, 1.0);
    info.NdotV = clamp(dot(n, v), 0.0, 1.0);
    info.NdotH = clamp(dot(n, h), 0.0, 1.0);
    info.LdotH = clamp(dot(l, h), 0.0, 1.0);
    info.VdotH = clamp(dot(v, h), 0.0, 1.0);

    return info;
}

float GetPerceivedBrightness(float3 rgb)
{
    return sqrt(0.299 * rgb.r * rgb.r + 0.587 * rgb.g * rgb.g + 0.114 * rgb.b * rgb.b);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34
float SolveMetallic(float3 diffuse, float3 specular, float oneMinusSpecularStrength)
{
    const float c_MinReflectance = 0.04;
    float specularBrightness = GetPerceivedBrightness(specular);
    if (specularBrightness < c_MinReflectance)
    {
        return 0.0;
    }

    float diffuseBrightness = GetPerceivedBrightness(diffuse);

    float a = c_MinReflectance;
    float b = diffuseBrightness * oneMinusSpecularStrength / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;
    float c = c_MinReflectance - specularBrightness;
    float D = b * b - 4.0 * a * c;

    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);
}


float3 SRGBtoLINEAR(float3 srgbIn)
{
#ifdef MANUAL_SRGB
#   ifdef SRGB_FAST_APPROXIMATION
	    float3 linOut = pow(srgbIn.xyz, float3(2.2, 2.2, 2.2));
#   else
	    float3 bLess  = step(float3(0.04045, 0.04045, 0.04045), srgbIn.xyz);
	    float3 linOut = mix( srgbIn.xyz/12.92, pow((srgbIn.xyz + float3(0.055, 0.055, 0.055)) / 1.055, float3(2.4, 2.4, 2.4)), bLess );
#   endif
	    return linOut;
#else
	return srgbIn;
#endif
}

float4 SRGBtoLINEAR(float4 srgbIn)
{
    return float4(SRGBtoLINEAR(srgbIn.xyz), srgbIn.w);
}


struct SurfaceInfo
{
    float  perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    float3 reflectance0;           // full reflectance color (normal incidence angle)

    float  alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    float3 diffuseColor;           // color contribution from diffuse lighting

    float  metallic;
    float3 reflectance90;          // reflectance color at grazing angle

    float3 specularColor;          // color contribution from specular lighting
};


float3 GetPointShade(float3 pointToLight, SurfaceInfo srfInfo, float3 normal, float3 view)
{
    AngularInfo angularInfo = GetAngularInfo(pointToLight, normal, view);

    // If one of the dot products is larger than zero, no division by zero can happen. Avoids black borders.
    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)
    {
        // Calculate the shading terms for the microfacet specular shading model
        float3 F   = SchlickReflection(angularInfo.VdotH, srfInfo.reflectance0, srfInfo.reflectance90);
        float  Vis = SmithGGXVisibilityCorrelated(angularInfo.NdotL, angularInfo.NdotV, srfInfo.alphaRoughness);
        float  D   = MicrofacetDistribution(angularInfo.NdotH, srfInfo.alphaRoughness);

        // Calculation of analytical lighting contribution
        float3 diffuseContrib = (1.0 - F) * LambertianDiffuse(srfInfo.diffuseColor);
        float3 specContrib    = F * Vis * D;

        // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
        return angularInfo.NdotL * (diffuseContrib + specContrib);
    }

    return float3(0.0, 0.0, 0.0);
}

float3 ApplyDirectionalLight(float3 lightDir, float3 lightColor, SurfaceInfo srfInfo, float3 normal, float3 view)
{
    float3 pointToLight = -lightDir;
    float3 shade = GetPointShade(pointToLight, srfInfo, normal, view);
    return lightColor * shade;
}


// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
float3 PerturbNormal(in float3 Position, in float3 Normal, in float3 TSNormal, in float2 UV)
{
    // Retrieve the tangent space matrix
    float3 pos_dx = ddx(Position);
    float3 pos_dy = ddy(Position);
    float3 tex_dx = ddx(float3(UV, 0.0));
    float3 tex_dy = ddy(float3(UV, 0.0));
    float3 t = (tex_dy.y * pos_dx - tex_dx.y * pos_dy) / (tex_dx.x * tex_dy.y - tex_dy.x * tex_dx.y);

//#ifdef HAS_NORMALS
    float3 ng = normalize(Normal);
//#else
//    float3 ng = cross(pos_dx, pos_dy);
//#endif

    t = normalize(t - ng * dot(ng, t));
    float3 b = normalize(cross(ng, t));
    float3x3 tbn = MatrixFromRows(t, b, ng);

    TSNormal = 2.0 * TSNormal - float3(1.0, 1.0, 1.0);
    return normalize(mul(TSNormal, tbn));
}


/*
// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
float3 getIBLContribution(PBRInfo pbrInputs, float3 n, float3 reflection)
{
	float lod = (pbrInputs.perceptualRoughness * uboParams.prefilteredCubeMipLevels);
	// retrieve a scale and bias to F0. See [1], Figure 3
	float3 brdf = (texture(samplerBRDFLUT, float2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
	float3 diffuseLight = SRGBtoLINEAR(tonemap(texture(samplerIrradiance, n))).rgb;

	float3 specularLight = SRGBtoLINEAR(tonemap(textureLod(prefilteredMap, reflection, lod))).rgb;

	float3 diffuse = diffuseLight * pbrInputs.diffuseColor;
	float3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);

	// For presentation, this allows us to disable IBL terms
	// For presentation, this allows us to disable IBL terms
	diffuse *= uboParams.scaleIBLAmbient;
	specular *= uboParams.scaleIBLAmbient;

	return diffuse + specular;
}
*/



void main(in  float4 ClipPos  : SV_Position,
          in  float3 WorldPos : WORLD_POS,
          in  float3 Normal   : NORMAL,
          in  float2 UV0      : UV0,
          in  float2 UV1      : UV1,
          out float4 OutColor : SV_Target)
{
    float4 BaseColor = g_ColorMap.Sample(g_ColorMap_sampler, lerp(UV0, UV1, g_MaterialInfo.BaseColorTextureUVSelector));
    BaseColor = SRGBtoLINEAR(BaseColor) * g_MaterialInfo.BaseColorFactor;
    //BaseColor *= getVertexColor();

	if (g_MaterialInfo.UseAlphaMask != 0 && BaseColor.a < g_MaterialInfo.AlphaMaskCutoff)
    {
		discard;
	}
    
    float2 NormalMapUV  = lerp(UV0, UV1, g_MaterialInfo.NormalTextureUVSelector);
    float3 TSNormal     = g_NormalMap            .Sample(g_NormalMap_sampler,             NormalMapUV).rgb;
    float  Occlusion    = g_AOMap                .Sample(g_AOMap_sampler,                 lerp(UV0, UV1, g_MaterialInfo.OcclusionTextureUVSelector)).r;
    float3 Emissive     = g_EmissiveMap          .Sample(g_EmissiveMap_sampler,           lerp(UV0, UV1, g_MaterialInfo.EmissiveTextureUVSelector)).rgb;
    float4 PhysicalDesc = g_PhysicalDescriptorMap.Sample(g_PhysicalDescriptorMap_sampler, lerp(UV0, UV1, g_MaterialInfo.PhysicalDescriptorTextureUVSelector));
    
    SurfaceInfo SrfInfo;
   
    float3 f0            = float3(0.04, 0.04, 0.04);

    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    if (g_MaterialInfo.Workflow == PBR_WORKFLOW_SPECULAR_GLOSINESS)
    {
        const float u_GlossinessFactor = 1.0;
        SrfInfo.perceptualRoughness = (1.0 - PhysicalDesc.a * u_GlossinessFactor); // glossiness to roughness
        f0 = PhysicalDesc.rgb * g_MaterialInfo.SpecularFactor.rgb;

        // f0 = specular
        SrfInfo.specularColor = f0;
        float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);
        SrfInfo.diffuseColor = BaseColor.rgb * oneMinusSpecularStrength;

        // do conversion between metallic M-R and S-G metallic
        SrfInfo.metallic = SolveMetallic(BaseColor.rgb, SrfInfo.specularColor, oneMinusSpecularStrength);
    }
    else if (g_MaterialInfo.Workflow == PBR_WORKFLOW_METALLIC_ROUGHNESS)
    {
        // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
        // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
        SrfInfo.perceptualRoughness = PhysicalDesc.g * g_MaterialInfo.RoughnessFactor;
        SrfInfo.metallic            = PhysicalDesc.b * g_MaterialInfo.MetallicFactor;

        SrfInfo.diffuseColor  = BaseColor.rgb * (float3(1.0, 1.0, 1.0) - f0) * (1.0 - SrfInfo.metallic);
        SrfInfo.specularColor = lerp(f0, BaseColor.rgb, SrfInfo.metallic);
    }

//#ifdef ALPHAMODE_OPAQUE
//    baseColor.a = 1.0;
//#endif
//
//#ifdef MATERIAL_UNLIT
//    gl_FragColor = float4(gammaCorrection(baseColor.rgb), baseColor.a);
//    return;
//#endif

    SrfInfo.perceptualRoughness = clamp(SrfInfo.perceptualRoughness, 0.0, 1.0);
    SrfInfo.metallic            = clamp(SrfInfo.metallic,            0.0, 1.0);

    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    SrfInfo.alphaRoughness = SrfInfo.perceptualRoughness * SrfInfo.perceptualRoughness;

    // Compute reflectance.
    float reflectance = max(max(SrfInfo.specularColor.r, SrfInfo.specularColor.g), SrfInfo.specularColor.b);

    SrfInfo.reflectance0  = SrfInfo.specularColor.rgb;
    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to "Real-Time-Rendering" 4th editon on page 325.
    SrfInfo.reflectance90 = clamp(reflectance * 50.0, 0.0, 1.0).xxx;

    // LIGHTING

    float3 color           = float3(0.0, 0.0, 0.0);
    float3 perturbedNormal = PerturbNormal(WorldPos, Normal, TSNormal, NormalMapUV);
    float3 view            = normalize(g_CameraAttribs.f4Position.xyz - WorldPos.xyz); // Direction from surface point to camera

    color += ApplyDirectionalLight(g_LightAttribs.f4Direction.xyz, g_LightAttribs.f4Intensity.rgb, SrfInfo, perturbedNormal, view);
    
//#ifdef USE_PUNCTUAL
//    for (int i = 0; i < LIGHT_COUNT; ++i)
//    {
//        Light light = u_Lights[i];
//        if (light.type == LightType_Directional)
//        {
//            color += applyDirectionalLight(light, materialInfo, normal, view);
//        }
//        else if (light.type == LightType_Point)
//        {
//            color += applyPointLight(light, materialInfo, normal, view);
//        }
//        else if (light.type == LightType_Spot)
//        {
//            color += applySpotLight(light, materialInfo, normal, view);
//        }
//    }
//#endif
//
    // Calculate lighting contribution from image based lighting source (IBL)
//#ifdef USE_IBL
//    color += getIBLContribution(materialInfo, normal, view);
//#endif
//

    color = lerp(color, color * Occlusion, g_RenderParameters.OcclusionStrength);

    const float u_EmissiveFactor = 1.0f;
    Emissive = SRGBtoLINEAR(Emissive);
    color += Emissive.rgb * g_MaterialInfo.EmissiveFactor.rgb * g_RenderParameters.EmissionScale;

    ToneMappingAttribs TMAttribs;
    TMAttribs.uiToneMappingMode    = TONE_MAPPING_MODE_UNCHARTED2;
    TMAttribs.bAutoExposure        = false;
    TMAttribs.fMiddleGray          = g_RenderParameters.MiddleGray;
    TMAttribs.bLightAdaptation     = false;
    TMAttribs.fWhitePoint          = g_RenderParameters.WhitePoint;
    TMAttribs.fLuminanceSaturation = 1.0;
    color = ToneMap(color, TMAttribs, g_RenderParameters.AverageLogLum);
    OutColor = float4(color, BaseColor.a);

#if ALLOW_DEBUG_VIEW
	// Shader inputs debug visualization
	if (g_RenderParameters.DebugViewType != 0)
    {
 		switch (g_RenderParameters.DebugViewType)
        {
			case  1: OutColor.rgba = BaseColor;                       break;
			case  2: OutColor.rgb  = TSNormal.xyz;                    break;
			case  3: OutColor.rgb  = Occlusion.xxx;                   break;
			case  4: OutColor.rgb  = Emissive.rgb;                    break;
			case  5: OutColor.rgb  = SrfInfo.perceptualRoughness.rrr; break;
			case  6: OutColor.rgb  = SrfInfo.metallic.rrr;            break;
            case  7: OutColor.rgb  = SrfInfo.diffuseColor;            break;
            case  8: OutColor.rgb  = SrfInfo.specularColor;           break;
            case  9: OutColor.rgb  = SrfInfo.reflectance90;           break;
            case 10: OutColor.rgb  = abs(Normal);                     break;
            case 11: OutColor.rgb  = abs(perturbedNormal);            break;
            case 12: OutColor.rgb  = dot(perturbedNormal, view).xxx;  break;
		}
	}
#endif

}
