// PBR shader based on the Khronos WebGL PBR implementation
// See https://github.com/KhronosGroup/glTF-WebGL-PBR
// Supports both metallic roughness and specular glossiness inputs

#include "BasicStructures.fxh"
#include "PBR_Shading.fxh"
#include "RenderPBR_Structures.fxh"

#if ENABLE_TONE_MAPPING
#   include "ToneMapping.fxh"
#endif

#include "VSOutputStruct.generated"
// struct VSOutput
// {
//     float4 ClipPos  : SV_Position;
//     float3 WorldPos : WORLD_POS;
//     float4 Color    : COLOR;
//     float3 Normal   : NORMAL;
//     float2 UV0      : UV0;
//     float2 UV1      : UV1;
// };

#ifndef USE_TEXTURE_ATLAS
#   define USE_TEXTURE_ATLAS 0
#endif

#ifndef ALLOW_DEBUG_VIEW
#   define ALLOW_DEBUG_VIEW 0
#endif

#include "PBR_Textures.fxh"

cbuffer cbFrameAttribs
{
    PBRFrameAttribs g_Frame;
}

cbuffer cbPrimitiveAttribs
{
    PBRPrimitiveAttribs g_Primitive;
}

float4 ComputePbrSurfaceColor(in VSOutput VSOut,
                              in bool     IsFrontFace)
{
    float4 BaseColor = GetBaseColor(VSOut, g_Primitive.Material);

    PBRMaterialTextureAttribs NormalTexAttribs = g_Primitive.Material.Textures[NormalTextureAttribId];

    float2 NormalMapUV = SelectUV(VSOut, NormalTexAttribs.UVSelector);

    // We have to compute gradients in uniform flow control to avoid issues with perturbed normal
    float3 dWorldPos_dx = ddx(VSOut.WorldPos);
    float3 dWorldPos_dy = ddy(VSOut.WorldPos);
#if ENABLE_TEXCOORD_TRANSFORM
    NormalMapUV = TransformUV(NormalMapUV, NormalTexAttribs);
#endif
    float2 SmoothNormalMapUV = NormalMapUV;
    float2 dNormalMapUV_dx = ddx(NormalMapUV);
    float2 dNormalMapUV_dy = ddy(NormalMapUV);
#if USE_TEXTURE_ATLAS
    {
        NormalMapUV = frac(NormalMapUV) * NormalTexAttribs.AtlasUVScaleAndBias.xy + NormalTexAttribs.AtlasUVScaleAndBias.zw;
        SmoothNormalMapUV *= NormalTexAttribs.AtlasUVScaleAndBias.xy;
        dNormalMapUV_dx   *= NormalTexAttribs.AtlasUVScaleAndBias.xy;
        dNormalMapUV_dy   *= NormalTexAttribs.AtlasUVScaleAndBias.xy;
    }
#endif

    PBRMaterialBasicAttribs BasicAttribs = g_Primitive.Material.Basic;
    if (BasicAttribs.AlphaMode == PBR_ALPHA_MODE_MASK && BaseColor.a < BasicAttribs.AlphaMaskCutoff)
    {
        discard;
    }

    float3 TSNormal     = GetMicroNormal(g_Primitive.Material, NormalMapUV, SmoothNormalMapUV, dNormalMapUV_dx, dNormalMapUV_dy);
    float  Occlusion    = GetOcclusion(VSOut, g_Primitive.Material);
    float3 Emissive     = GetEmissive(VSOut, g_Primitive.Material);
    float4 PhysicalDesc = GetPhysicalDesc(VSOut, g_Primitive.Material);

    if (BasicAttribs.Workflow == PBR_WORKFLOW_SPECULAR_GLOSINESS)
    {
        PhysicalDesc.rgb = TO_LINEAR(PhysicalDesc.rgb) * BasicAttribs.SpecularFactor.rgb;
        const float u_GlossinessFactor = 1.0;
        PhysicalDesc.a *= u_GlossinessFactor;
    }
    else if (BasicAttribs.Workflow == PBR_WORKFLOW_METALLIC_ROUGHNESS)
    {
        // PhysicalDesc should already be in linear space
        PhysicalDesc.g = saturate(PhysicalDesc.g * BasicAttribs.RoughnessFactor);
        PhysicalDesc.b = saturate(PhysicalDesc.b * BasicAttribs.MetallicFactor);
    }
    float metallic = 0.0;
    SurfaceReflectanceInfo SrfInfo = GetSurfaceReflectance(BasicAttribs.Workflow, BaseColor, PhysicalDesc, metallic);

    float3 view = normalize(g_Frame.Camera.f4Position.xyz - VSOut.WorldPos.xyz); // Direction from surface point to camera

#if USE_VERTEX_NORMALS
    float3 MeshNormal = VSOut.Normal;
#else
    // PerturbNormal can handle zero-length mesh normals.
    float3 MeshNormal = float3(0.0, 0.0, 0.0);
#endif

    float3 perturbedNormal;
    float3 DirectLighting;
    float3 color;
    
    IBL_Contribution IBLContrib;
    IBLContrib.f3Diffuse  = float3(0.0, 0.0, 0.0);
    IBLContrib.f3Specular = float3(0.0, 0.0, 0.0);

    if (BasicAttribs.Workflow != PBR_WORKFLOW_UNLIT)
    {
        perturbedNormal = PerturbNormal(dWorldPos_dx,
                                        dWorldPos_dy,
                                        dNormalMapUV_dx,
                                        dNormalMapUV_dy,
                                        MeshNormal,
                                        TSNormal,
                                        NormalTexAttribs.UVSelector >= 0.0,
                                        IsFrontFace);

        DirectLighting = ApplyDirectionalLight(g_Frame.Light.Direction.xyz, g_Frame.Light.Intensity.rgb, SrfInfo, perturbedNormal, view);
        color = DirectLighting;

        //#ifdef USE_PUNCTUAL
        //    for (int i = 0; i < LIGHT_COUNT; ++i)
        //    {
        //        Light light = u_Lights[i];
        //        if (light.type == LightType_Directional)
        //        {
        //            color += applyDirectionalLight(light, materialInfo, normal, view);
        //        }
        //        else if (light.type == LightType_Point)
        //        {
        //            color += applyPointLight(light, materialInfo, normal, view);
        //        }
        //        else if (light.type == LightType_Spot)
        //        {
        //            color += applySpotLight(light, materialInfo, normal, view);
        //        }
        //    }
        //#endif
        //

        // Calculate lighting contribution from image based lighting source (IBL)
#       if USE_IBL
        {
            IBLContrib =
                GetIBLContribution(SrfInfo, perturbedNormal, view, float(g_Frame.Renderer.PrefilteredCubeMipLevels),
                                   g_BRDF_LUT,          g_BRDF_LUT_sampler,
                                   g_IrradianceMap,     g_IrradianceMap_sampler,
                                   g_PrefilteredEnvMap, g_PrefilteredEnvMap_sampler);
            color += (IBLContrib.f3Diffuse + IBLContrib.f3Specular) * g_Frame.Renderer.IBLScale;
        }
#       endif
    }
    else
    {
        perturbedNormal = float3(0.0, 0.0, 0.0);
        DirectLighting  = float3(0.0, 0.0, 0.0);
        color           = BaseColor.rgb;
    }

#   if USE_AO_MAP
    {
        color = lerp(color, color * Occlusion, g_Frame.Renderer.OcclusionStrength);
    }
#endif

#   if USE_EMISSIVE_MAP
    {
        color += Emissive.rgb * g_Frame.Renderer.EmissionScale;
    }
#   endif

#if ENABLE_TONE_MAPPING
    {
        // Perform tone mapping
        ToneMappingAttribs TMAttribs;
        TMAttribs.iToneMappingMode     = TONE_MAPPING_MODE;
        TMAttribs.bAutoExposure        = false;
        TMAttribs.fMiddleGray          = g_Frame.Renderer.MiddleGray;
        TMAttribs.bLightAdaptation     = false;
        TMAttribs.fWhitePoint          = g_Frame.Renderer.WhitePoint;
        TMAttribs.fLuminanceSaturation = 1.0;
        color = ToneMap(color, TMAttribs, g_Frame.Renderer.AverageLogLum);
    }
#endif

    // Add highlight color
    color = lerp(color, g_Frame.Renderer.HighlightColor.rgb, g_Frame.Renderer.HighlightColor.a);

    float4 OutColor = float4(color, BaseColor.a);

    // Shader inputs debug visualization
#if (DEBUG_VIEW == DEBUG_VIEW_BASE_COLOR)
    {
        OutColor.rgba = BaseColor;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_TEXCOORD0 && USE_TEXCOORD0)
    {
        OutColor.rgb = float3(VSOut.UV0, 0.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_TEXCOORD1 && USE_TEXCOORD1)
    {
        OutColor.rgb = float3(VSOut.UV1, 0.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_TRANSPARENCY)
    {
        OutColor.rgba = float4(BaseColor.a, BaseColor.a, BaseColor.a, 1.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_NORMAL_MAP)
    {
        OutColor.rgb = TSNormal.xyz;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_OCCLUSION)
    {
        OutColor.rgb  = Occlusion * float3(1.0, 1.0, 1.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_EMISSIVE)
    {
        OutColor.rgb  = Emissive.rgb;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_METALLIC)
    {
        OutColor.rgb  = metallic * float3(1.0, 1.0, 1.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_ROUGHNESS)
    {
        OutColor.rgb  = SrfInfo.PerceptualRoughness * float3(1.0, 1.0, 1.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_DIFFUSE_COLOR)
    {
        OutColor.rgb  = SrfInfo.DiffuseColor;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_SPECULAR_COLOR)
    {
        OutColor.rgb  = SrfInfo.Reflectance0;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_REFLECTANCE90)
    {
        OutColor.rgb  = SrfInfo.Reflectance90;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_MESH_NORMAL)
    {
        OutColor.rgb  = abs(MeshNormal/ max(length(MeshNormal), 1e-3));
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_PERTURBED_NORMAL)
    {
        OutColor.rgb  = abs(perturbedNormal);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_NDOTV)
    {
        OutColor.rgb  = dot(perturbedNormal, view) * float3(1.0, 1.0, 1.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_DIRECT_LIGHTING)
    {
        OutColor.rgb  = DirectLighting;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_DIFFUSE_IBL && USE_IBL)
    {
        OutColor.rgb  = IBLContrib.f3Diffuse;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_SPECULAR_IBL && USE_IBL)
    {
        OutColor.rgb  = IBLContrib.f3Specular;
    }
#endif


#if CONVERT_OUTPUT_TO_SRGB
    {
        OutColor.rgb = FastLinearToSRGB(OutColor.rgb);
    }
#endif

    return OutColor;
}


#include "PSMainGenerated.generated"
// struct PSOutput
// {
//     float4 Color      : SV_Target0;
//     float4 CustomData : SV_Target1;
// };
//
// void main(in VSOutput VSOut,
//           in bool IsFrontFace : SV_IsFrontFace,
//           out PSOutput PSOut)
// {
//     PSOut.Color = ComputePbrSurfaceColor(VSOut, IsFrontFace);
// 
// #if ENABLE_CUSTOM_DATA_OUTPUT
//     {
//         PSOut.CustomData = g_Primitive.CustomData;
//     }
// #endif
// }
