// PBR shader based on the Khronos WebGL PBR implementation
// See https://github.com/KhronosGroup/glTF-WebGL-PBR
// Supports both metallic roughness and specular glossiness inputs

#include "BasicStructures.fxh"
#include "PBR_Shading.fxh"
#include "RenderPBR_Structures.fxh"

#if ENABLE_TONE_MAPPING
#   include "ToneMapping.fxh"
#endif

#include "VSOutputStruct.generated"
// struct VSOutput
// {
//     float4 ClipPos  : SV_Position;
//     float3 WorldPos : WORLD_POS;
//     float4 Color    : COLOR;
//     float3 Normal   : NORMAL;
//     float2 UV0      : UV0;
//     float2 UV1      : UV1;
// };

#ifndef USE_TEXTURE_ATLAS
#   define USE_TEXTURE_ATLAS 0
#endif

#ifndef ALLOW_DEBUG_VIEW
#   define ALLOW_DEBUG_VIEW 0
#endif

#include "PBR_Textures.fxh"

cbuffer cbFrameAttribs
{
    PBRFrameAttribs g_Frame;
}

cbuffer cbPrimitiveAttribs
{
    PBRPrimitiveAttribs g_Primitive;
}

struct NormalMapUVInfo
{
    float  Selector;
    float2 UV;
    float2 SmoothUV;
    float2 dUV_dx;
    float2 dUV_dy;
};

NormalMapUVInfo GetNormalMapUVInfo(in VSOutput VSOut, in PBRMaterialTextureAttribs TexAttribs)
{
    NormalMapUVInfo UVInfo;
    
    UVInfo.Selector = TexAttribs.UVSelector;
    UVInfo.UV       = SelectUV(VSOut, TexAttribs.UVSelector);

#if ENABLE_TEXCOORD_TRANSFORM
    UVInfo.UV = TransformUV(UVInfo.UV, TexAttribs);
#endif
    
    UVInfo.SmoothUV = UVInfo.UV;
    UVInfo.dUV_dx   = ddx(UVInfo.UV);
    UVInfo.dUV_dy   = ddy(UVInfo.UV);
#if USE_TEXTURE_ATLAS
    {
        UVInfo.UV = frac(UVInfo.UV) * TexAttribs.AtlasUVScaleAndBias.xy + TexAttribs.AtlasUVScaleAndBias.zw;
        UVInfo.SmoothUV *= TexAttribs.AtlasUVScaleAndBias.xy;
        UVInfo.dUV_dx   *= TexAttribs.AtlasUVScaleAndBias.xy;
        UVInfo.dUV_dy   *= TexAttribs.AtlasUVScaleAndBias.xy;
    }
#endif
    
    return UVInfo;
}

BaseLayerShadingInfo ReadBaseLayerProperties(in VSOutput          VSOut,
                                             in float4            BaseColor,
                                             in PerturbNormalInfo NormalInfo,
                                             in NormalMapUVInfo   NMUVInfo,
                                             in float3            View, 
                                             in bool              IsFrontFace)
{
    BaseLayerShadingInfo Base;
    
    float3 TSNormal     = GetMicroNormal(g_Primitive.Material, NMUVInfo.UV, NMUVInfo.SmoothUV, NMUVInfo.dUV_dx, NMUVInfo.dUV_dy);
    float4 PhysicalDesc = GetPhysicalDesc(VSOut, g_Primitive.Material);
    
    PBRMaterialBasicAttribs BasicAttribs = g_Primitive.Material.Basic;
    if (BasicAttribs.Workflow == PBR_WORKFLOW_SPECULAR_GLOSINESS)
    {
        PhysicalDesc.rgb = TO_LINEAR(PhysicalDesc.rgb) * BasicAttribs.SpecularFactor.rgb;
        const float u_GlossinessFactor = 1.0;
        PhysicalDesc.a *= u_GlossinessFactor;
    }
    else if (BasicAttribs.Workflow == PBR_WORKFLOW_METALLIC_ROUGHNESS)
    {
        // PhysicalDesc should already be in linear space
        PhysicalDesc.g = saturate(PhysicalDesc.g * BasicAttribs.RoughnessFactor);
        PhysicalDesc.b = saturate(PhysicalDesc.b * BasicAttribs.MetallicFactor);
    }
    Base.Metallic = 0.0;
    Base.Srf = GetSurfaceReflectance(BasicAttribs.Workflow, BaseColor, PhysicalDesc, Base.Metallic);
    
    Base.Normal = PerturbNormal(NormalInfo,
                                NMUVInfo.dUV_dx,
                                NMUVInfo.dUV_dy,
                                TSNormal,
                                NMUVInfo.Selector >= 0.0,
                                IsFrontFace);
    
    Base.NdotV = saturate(dot(Base.Normal, View));
    
    return Base;
}

#if ENABLE_CLEAR_COAT
ClearcoatShadingInfo ReadClearcoatLayerProperties(in VSOutput          VSOut,
                                                  in PerturbNormalInfo NormalInfo,
                                                  in NormalMapUVInfo   NMUVInfo,
                                                  in bool              IsFrontFace)
{
    ClearcoatShadingInfo Clearcoat;

    Clearcoat.Factor  = GetClearcoatFactor(VSOut, g_Primitive.Material);

    float  ClearCoatRoughness = GetClearcoatRoughness(VSOut, g_Primitive.Material);
    float3 ClearCoatNormal    = GetClearcoatNormal(g_Primitive.Material, NMUVInfo.UV, NMUVInfo.SmoothUV, NMUVInfo.dUV_dx, NMUVInfo.dUV_dy);
    
    float IOR = 1.5;
    Clearcoat.Srf = GetSurfaceReflectanceClearCoat(ClearCoatRoughness, IOR);

    Clearcoat.Normal = NormalInfo.Normal;
#   if USE_CLEAR_COAT_NORMAL_MAP
    {
        // If clearcoatNormalTexture is not given, no normal mapping is applied to the clear coat layer,
        // even if normal mapping is applied to the base material.
        if (NMUVInfo.Selector >= 0)
        {
            Clearcoat.Normal = PerturbNormal(NormalInfo,
                                             NMUVInfo.dUV_dx,
                                             NMUVInfo.dUV_dy,
                                             ClearCoatNormal,
                                             true,
                                             IsFrontFace);
        }
    }
#   endif

    return Clearcoat;
}
#endif

#if ENABLE_SHEEN
SheenShadingInfo ReadSheenLayerProperties(in VSOutput VSOut)
{
    SheenShadingInfo Sheen;
    
    Sheen.Color     = GetSheenColor(VSOut, g_Primitive.Material);
    Sheen.Roughness = GetSheenRoughness(VSOut, g_Primitive.Material);

    return Sheen;
}
#endif

float4 ComputePbrSurfaceColor(in VSOutput VSOut,
                              in bool     IsFrontFace)
{
    float4 BaseColor = GetBaseColor(VSOut, g_Primitive.Material);

#if USE_VERTEX_NORMALS
    float3 MeshNormal = VSOut.Normal;
#else
    // PerturbNormal can handle zero-length mesh normals.
    float3 MeshNormal = float3(0.0, 0.0, 0.0);
#endif
    // We have to compute gradients in uniform flow control to avoid issues with perturbed normal
    PerturbNormalInfo NormalInfo = GetPerturbNormalInfo(VSOut.WorldPos, MeshNormal);
    
    PBRMaterialTextureAttribs NormalTexAttribs = g_Primitive.Material.Textures[NormalTextureAttribId];
    NormalMapUVInfo           NMUVInfo         = GetNormalMapUVInfo(VSOut, NormalTexAttribs);
    
#if USE_CLEAR_COAT_NORMAL_MAP
    PBRMaterialTextureAttribs ClearCoatNormalTexAttribs = g_Primitive.Material.Textures[ClearCoatNormalTextureAttribId];
    NormalMapUVInfo           ClearCoatNMUVInfo         = GetNormalMapUVInfo(VSOut, ClearCoatNormalTexAttribs);
#endif

    PBRMaterialBasicAttribs BasicAttribs = g_Primitive.Material.Basic;
    if (BasicAttribs.AlphaMode == PBR_ALPHA_MODE_MASK && BaseColor.a < BasicAttribs.AlphaMaskCutoff)
    {
        discard;
    }

    SurfaceShadingInfo Shading;
    Shading.View      = normalize(g_Frame.Camera.f4Position.xyz - VSOut.WorldPos.xyz); // Direction from surface point to camera
    Shading.BaseLayer = ReadBaseLayerProperties(VSOut, BaseColor, NormalInfo, NMUVInfo, Shading.View, IsFrontFace);
    Shading.Occlusion = GetOcclusion(VSOut, g_Primitive.Material);
    Shading.Emissive  = GetEmissive(VSOut, g_Primitive.Material);
    
    Shading.IBLScale          = g_Frame.Renderer.IBLScale;
    Shading.OcclusionStrength = g_Frame.Renderer.OcclusionStrength;
    Shading.EmissionScale     = g_Frame.Renderer.EmissionScale;

#   if ENABLE_CLEAR_COAT
    {
        Shading.Clearcoat = ReadClearcoatLayerProperties(VSOut, NormalInfo, ClearCoatNMUVInfo, IsFrontFace); 
    }
#   endif
    
#if ENABLE_SHEEN
    {    
        Shading.Sheen = ReadSheenLayerProperties(VSOut);
    }
#   endif
    
#if ENABLE_ANISOTROPY
    {
        Shading.Anisotropy = GetAnisotropy(VSOut, g_Primitive.Material);
    }
#   endif
    
#   if ENABLE_IRIDESCENCE
    {
        Shading.Iridescence.Factor           = GetIridescence(VSOut, g_Primitive.Material);
        Shading.Iridescence.Thickness        = GetIridescenceThickness(VSOut, g_Primitive.Material);
        Shading.Iridescence.ThicknessMinimum = g_Primitive.Material.Iridescence.ThicknessMinimum;
        Shading.Iridescence.ThicknessMaximum = g_Primitive.Material.Iridescence.ThicknessMaximum;
    }
#   endif
    
#   if ENABLE_TRANSMISSION
    {
        Shading.Transmission = GetTransmission(VSOut, g_Primitive.Material);
    }
#   endif
    
#if ENABLE_VOLUME
    {
        Shading.VolumeThickness = GetVolumeThickness(VSOut, g_Primitive.Material);
    }
#endif
            
    SurfaceLightingInfo SrfLighting = GetDefaultSurfaceLightingInfo();

    if (BasicAttribs.Workflow != PBR_WORKFLOW_UNLIT)
    {
        ApplyPunctualLights(
            Shading,
            g_Frame.Light,
#if     ENABLE_SHEEN
            g_SheenAlbedoScalingLUT,
            g_SheenAlbedoScalingLUT_sampler,
#endif
            SrfLighting);

#       if USE_IBL
        {
            ApplyIBL(Shading, float(g_Frame.Renderer.PrefilteredCubeMipLevels),
                     g_PreintegratedGGX,  g_PreintegratedGGX_sampler,
                     g_IrradianceMap,     g_IrradianceMap_sampler,
                     g_PrefilteredEnvMap, g_PrefilteredEnvMap_sampler,
                     SrfLighting);
        }
#       endif
    }
    
    float4 OutColor;
    OutColor.rgb = ResolveLighting(Shading, SrfLighting);
    OutColor.a   = BaseColor.a;
        
#if ENABLE_TONE_MAPPING
    {
        // Perform tone mapping
        ToneMappingAttribs TMAttribs;
        TMAttribs.iToneMappingMode     = TONE_MAPPING_MODE;
        TMAttribs.bAutoExposure        = false;
        TMAttribs.fMiddleGray          = g_Frame.Renderer.MiddleGray;
        TMAttribs.bLightAdaptation     = false;
        TMAttribs.fWhitePoint          = g_Frame.Renderer.WhitePoint;
        TMAttribs.fLuminanceSaturation = 1.0;
        OutColor.rgb = ToneMap(OutColor.rgb, TMAttribs, g_Frame.Renderer.AverageLogLum);
    }
#endif

    // Add highlight color
    OutColor.rgb = lerp(OutColor.rgb, g_Frame.Renderer.HighlightColor.rgb, g_Frame.Renderer.HighlightColor.a);

    
    // Shader inputs debug visualization
#if (DEBUG_VIEW == DEBUG_VIEW_BASE_COLOR)
    {
        OutColor.rgba = BaseColor;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_TEXCOORD0 && USE_TEXCOORD0)
    {
        OutColor.rgb = float3(VSOut.UV0, 0.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_TEXCOORD1 && USE_TEXCOORD1)
    {
        OutColor.rgb = float3(VSOut.UV1, 0.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_TRANSPARENCY)
    {
        OutColor.rgba = float4(BaseColor.a, BaseColor.a, BaseColor.a, 1.0);
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_NORMAL_MAP)
    {
        //OutColor.rgb = TSNormal.xyz;
    }
#elif (DEBUG_VIEW == DEBUG_VIEW_MESH_NORMAL)
    {
        OutColor.rgb  = MeshNormal * float3(0.5, 0.5, 0.5) + float3(0.5, 0.5, 0.5);
    }
#elif (DEBUG_VIEW != DEBUG_VIEW_NONE)
    {
        OutColor.rgb = GetDebugColor(Shading, SrfLighting);
    }
#endif
    

#if CONVERT_OUTPUT_TO_SRGB
    {
        OutColor.rgb = FastLinearToSRGB(OutColor.rgb);
    }
#endif

    return OutColor;
}


#include "PSMainGenerated.generated"
// struct PSOutput
// {
//     float4 Color      : SV_Target0;
//     float4 CustomData : SV_Target1;
// };
//
// void main(in VSOutput VSOut,
//           in bool IsFrontFace : SV_IsFrontFace,
//           out PSOutput PSOut)
// {
//     PSOut.Color = ComputePbrSurfaceColor(VSOut, IsFrontFace);
// 
// #if ENABLE_CUSTOM_DATA_OUTPUT
//     {
//         PSOut.CustomData = g_Primitive.CustomData;
//     }
// #endif
// }
