// Generates an irradiance cube from an environment map using convolution

#include "PBR_PrecomputeCommon.fxh"
#include "ShaderUtilities.fxh"

#ifndef OPTIMIZE_SAMPLES
#   define OPTIMIZE_SAMPLES 1
#endif

#if ENV_MAP_TYPE == ENV_MAP_TYPE_CUBE
TextureCube  g_EnvironmentMap;
#elif ENV_MAP_TYPE == ENV_MAP_TYPE_SPHERE
Texture2D    g_EnvironmentMap;
#endif

SamplerState g_EnvironmentMap_sampler;

cbuffer FilterAttribs
{
    float4x4 g_RotationUnused;

    float g_Roughness;
    float g_EnvMapWidth;
    float g_EnvMapHeight;
    uint  g_NumSamples;
}

float3 SampleEnvrionmentMap(float3 R, float MipLevel)
{
#if ENV_MAP_TYPE == ENV_MAP_TYPE_CUBE
    return g_EnvironmentMap.SampleLevel(g_EnvironmentMap_sampler, R, MipLevel).rgb;
#elif ENV_MAP_TYPE == ENV_MAP_TYPE_SPHERE
    return g_EnvironmentMap.SampleLevel(g_EnvironmentMap_sampler, TransformDirectionToSphereMapUV(R), MipLevel).rgb;
#endif
}

float3 IrradianceMap(float3 N)
{
    // When the HDRI map has points occupying a small area but with high peak brightness (such as the sun), brightness spikes appear on the irradiance map. 
    // To resolve this issue, we used the approach from the comments in this post:
    // https://www.reddit.com/r/opengl/comments/l0h5fy/rendering_the_irradiance_map_for_physically_based/
    float3 Irradiance = float3(0.0, 0.0, 0.0);   
    for (uint i = 0u; i < g_NumSamples; ++i)
    {
        float2 Xi = Hammersley2D(i, g_NumSamples);
        
        // Importance sample the hemisphere with a cosine-weighted distribution
        float3 L = ImportanceSampleGGX(Xi, 1.0, N);

 #if OPTIMIZE_SAMPLES       
        // NdotL is equal to cos(theta)
        float NoL = max(dot(N, L), 0.0);
        
        // Probability density function for cosine-weighted hemisphere
        float pdf = max((1.0 / PI) * NoL, 0.0001);

        // Solid angle of current smple
        float OmegaS = 1.0 / (float(g_NumSamples) * pdf);
        
        float NumPixels = g_EnvMapWidth * g_EnvMapHeight;
#if ENV_MAP_TYPE == ENV_MAP_TYPE_CUBE
        NumPixels *= 6.0;
#endif
        
        // Solid angle of 1 pixel across all cube faces
        float OmegaP = 4.0 * PI / NumPixels;
        
        // Applying mip bias produces better results, especially for environments maps with
        // very bright spots.
        float MipBias = 1.0;
        float MipLevel = max(0.5 * log2(OmegaS / OmegaP) + MipBias, 0.0);
#else
        float MipLevel = 0.0;
#endif
        Irradiance += SampleEnvrionmentMap(L, MipLevel);
    }
    return Irradiance / float(g_NumSamples);
}

void main(in float4 Pos      : SV_Position,
          in float3 WorldPos : WORLD_POS,
          out float4 Color   : SV_Target)
{
    float3 N = normalize(WorldPos);
    Color.rgb = IrradianceMap(N);
    Color.a = 1.0;
}
